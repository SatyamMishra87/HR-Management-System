import User from "../models/auth.js";
import Shift from "../models/Shift.js";
import Attendance from "../models/Attendance.js";
import Holiday from "../models/Holiday.js";
import LeaveApplication from "../models/leaveApplication.js";
import PaySchedule from "../models/paySchedule.js";
import OvertimePolicy from "../models/overTimePolicy.js";
import PenalisationPolicy from "../models/PenalisationPolicy.js";
import { getUTCRangeForISTDate, sameDay } from "../utils/time.js";
import { ENUMS } from "./constants.js";

const SalaryCalculationfunction = async (userId, startDate, endDate, grossSalary) => {
    if (!userId || !startDate || !endDate) throw new Error("userId, startDate and endDate are required");

    const user = await User.findById(userId);
    if (!user) throw new Error("User not found");

    const shift = await Shift.findOne({ assignUsers: userId });
    if (!shift) throw new Error("User not assigned to any shift");

    const holidays = await Holiday.find({
        assignUsers: userId,
        $or: [{ startDate: { $lte: endDate }, endDate: { $gte: startDate } }],
    });

    const leaveApplication = await LeaveApplication.find({
        userId,
        status: ENUMS.statusType.APPROVED,
        $or: [{ startDate: { $lte: endDate }, endDate: { $gte: startDate } }],
    }).populate("leavePolicyId");

    const existingAttendanceRecords = await Attendance.find({
        userId,
        date: { $gte: startDate, $lte: endDate }
    }).lean();

    const existingAttendanceMap = new Map();
    existingAttendanceRecords.forEach(att => {
        const key = att.date.toISOString().split('T')[0];
        existingAttendanceMap.set(key, att);
    });

    console.log("\n=== LOOP 1: AUTO-GENERATE ATTENDANCE + BUILD DAY INFO ===");
    const startIST = new Date(new Date(startDate).getTime() + 5.5 * 60 * 60 * 1000);
    const endIST = new Date(endDate.getTime());

    const attendanceToCreate = [];
    const dayInfos = [];
    let totalWorkingDays = 0, countWeekends = 0, countHolidays = 0;

    for (let cur = startIST.getTime(); cur <= endIST.getTime(); cur += 24 * 60 * 60 * 1000) {
        const curDate = new Date(cur);
        const y = curDate.getUTCFullYear();
        const m = curDate.getUTCMonth() + 1;
        const d = curDate.getUTCDate();

        const { startUTC, endUTC } = getUTCRangeForISTDate(y, m, d);
        const dateKey = startUTC.toISOString().split('T')[0];

        if (!existingAttendanceMap.has(dateKey)) {
            let dayStatus = ENUMS.DAY_STATUS.WORKING;

            const isHoliday = holidays.some(h => startUTC <= h.endDate && endUTC >= h.startDate);
            
            if (isHoliday) {
                dayStatus = ENUMS.DAY_STATUS.HOLIDAY;
            } else {
                const dayOfWeek = new Date(Date.UTC(y, m - 1, d)).getUTCDay();
                const shiftDay = shift.days.get(String(dayOfWeek));
                
                if (shiftDay && shiftDay.dayStatus) {
                    dayStatus = shiftDay.dayStatus;
                }
            }

            attendanceToCreate.push({
                userId,
                shiftId: shift._id,
                date: startUTC,
                dayStatus,
                clockIn: null,
                clockOut: null,
                totalWorkingTime: 0,
                ExtraTime: 0,
                islateIn: false,
                isEarlyOut: false,
                EarlyOutDuration: 0,
                autoGenerated: true
            });

            // Add to map for immediate use in PART 2
            existingAttendanceMap.set(dateKey, {
                date: startUTC,
                dayStatus,
                clockIn: null,
                clockOut: null,
                totalWorkingTime: 0,
                ExtraTime: 0,
                islateIn: false,
                isEarlyOut: false,
                EarlyOutDuration: 0
            });
        }

        // PART 2: Build dayInfos array
        const dayOfWeek = new Date(Date.UTC(y, m - 1, d)).getUTCDay();
        const shiftDay = shift.days.get(String(dayOfWeek));
        const shiftHours = (shiftDay?.dayStatus === ENUMS.DAY_STATUS.FIRSTHALF || shiftDay?.dayStatus === ENUMS.DAY_STATUS.SECONDHALF)
            ? (shift.halfDayHrs || 5)
            : (shift.fullDayHrs || 8);

        // Get attendance from map (already has newly created records)
        const attendanceForDay = existingAttendanceMap.get(dateKey) || null;

        const isWeekend = attendanceForDay?.dayStatus === ENUMS.DAY_STATUS.WEEKEND;
        const isHoliday = attendanceForDay?.dayStatus === ENUMS.DAY_STATUS.HOLIDAY;

        if (isWeekend) {
            countWeekends++;
            dayInfos.push({ startUTC, endUTC, isWeekend, isHoliday, shiftHours, shiftDay, attendanceForDay, type: 'WEEKEND' });
        } else if (isHoliday) {
            countHolidays++;
            dayInfos.push({ startUTC, endUTC, isWeekend, isHoliday, shiftHours, shiftDay, attendanceForDay, type: 'HOLIDAY' });
        } else {
            totalWorkingDays++;
            dayInfos.push({ startUTC, endUTC, isWeekend, isHoliday, shiftHours, shiftDay, attendanceForDay, type: 'WORKING' });
        }
    }

    if (attendanceToCreate.length > 0) {
        await Attendance.insertMany(attendanceToCreate);
        console.log(` Created ${attendanceToCreate.length} missing attendance records`);
    }

    const attendance = await Attendance.find({
        userId,
        date: { $gte: startDate, $lte: endDate }
    });

    attendance.forEach(att => {
        const dateKey = att.date.toISOString().split('T')[0];
        const dayInfo = dayInfos.find(di => di.startUTC.toISOString().split('T')[0] === dateKey);
        if (dayInfo) {
            dayInfo.attendanceForDay = att;
        }
    });

    console.log(`Total days processed: ${dayInfos.length}`);
    console.log(`Working days: ${totalWorkingDays}, Weekends: ${countWeekends}, Holidays: ${countHolidays}`);

    const paySchedule = await PaySchedule.findOne({ locationId: user.locationId });
    if (!paySchedule) throw new Error("PaySchedule not found for user's location");

    const penalisationPolicy = await PenalisationPolicy.findOne({ locationId: user.locationId });

    let overtimePolicy = null;
    if (user.assignedOvertimePolicy) {
        overtimePolicy = await OvertimePolicy.findById(user.assignedOvertimePolicy).lean();
    }

    if (totalWorkingDays === 0) totalWorkingDays = 1;

    const perDaySalary = grossSalary / totalWorkingDays;
    console.log("Per day salary:", perDaySalary);

    let presentDays = 0, absentDays = 0, paidLeaveDays = 0, unpaidLeaveDays = 0;
    let otSecondsWorking = 0, otSecondsWeekend = 0, otSecondsHoliday = 0;
    let totalOvertimeAmount = 0;

    let totalLateCount = 0;
    let totalEarlyOutCount = 0;
    let totalMissingClockOutCount = 0;

    let earlyOutTimeDeductionDays = 0;
    let penaltyDeductionDays = 0;
    let missingClockOutPenaltyAmount = 0;
    let instantLateInPenaltyAmount = 0;
    let instantEarlyOutPenaltyAmount = 0;

    const penaltyRule = penalisationPolicy?.penaltyRuleForLateWithEarlyOut || ENUMS.penaltyRuleType.BOTH;

    console.log("\n=== LOOP 2: PROCESS SALARY CALCULATION ===");
    
    for (const dayInfo of dayInfos) {
        const { startUTC, shiftHours, isWeekend, isHoliday, attendanceForDay, type } = dayInfo;
        const shiftSeconds = (shiftHours || 8) * 3600;

        console.log(`\n=== ${startUTC.toISOString().split('T')[0]} (${type}) ===`);

        // WEEKEND/HOLIDAY OVERTIME
        if (isWeekend || isHoliday) {
            if (attendanceForDay && attendanceForDay.clockIn && attendanceForDay.ExtraTime > 0 && paySchedule.payForExtraTime && overtimePolicy) {
                console.log(`${type} overtime detected`);
                const extraSeconds = Number(attendanceForDay.ExtraTime || 0);
                const perSecondSalary = Number(perDaySalary) / (Number(shiftHours) * 3600);

                if (isHoliday) otSecondsHoliday += extraSeconds;
                else otSecondsWeekend += extraSeconds;

                if (overtimePolicy.payFactorType === ENUMS.payFactorType.MULTIPLIER) {
                    const multiplier = isHoliday
                        ? (overtimePolicy.holidayMultiplier ?? 1.5)
                        : (overtimePolicy.weekendMultiplier ?? 1);
                    totalOvertimeAmount += extraSeconds * perSecondSalary * multiplier;
                    console.log(`OT: ${extraSeconds}s * ${perSecondSalary.toFixed(2)} * ${multiplier} = ${(extraSeconds * perSecondSalary * multiplier).toFixed(2)}`);
                } else if (overtimePolicy.payFactorType === ENUMS.payFactorType.FIXED_TOTAL) {
                    const perSecondFixed = (overtimePolicy.fixedTotal || 0) / 3600;
                    totalOvertimeAmount += extraSeconds * perSecondFixed;
                    console.log(`OT: ${extraSeconds}s * ${perSecondFixed.toFixed(2)} = ${(extraSeconds * perSecondFixed).toFixed(2)}`);
                }
            }
            continue;
        }

        // Check for leave
        let leaveFraction = 0, isPaidLeave = false, isUnpaidLeave = false;
        for (let lp of leaveApplication) {
            const policy = lp.leavePolicyId;
            const leaveDay = lp.leaveDays.find(ld => sameDay(ld.date, startUTC));
            if (leaveDay) {
                leaveFraction = leaveDay.leaveType === ENUMS.leaveType.FULL ? 1 : 0.5;
                if (policy.policyType === ENUMS.leavePolicyType.paidLeave) isPaidLeave = true;
                else if (policy.policyType === ENUMS.leavePolicyType.unpaidLeave) isUnpaidLeave = true;
                console.log(`Leave: ${leaveFraction} day, ${isPaidLeave ? 'PAID' : isUnpaidLeave ? 'UNPAID' : 'ABSENT'}`);
                break;
            }
        }

        // Missing clock out
        if (attendanceForDay && attendanceForDay.clockIn && !attendanceForDay.clockOut) {
            totalMissingClockOutCount++;
            console.log(" Missing clock out");

            const availableDay = 1 - leaveFraction;
            console.log(` Available: ${availableDay} (after ${leaveFraction} leave)`);

            if (!penalisationPolicy?.enableMissingClockOutPenalty) {
                absentDays += availableDay;
                console.log(` No policy - ${availableDay} absent`);
                
                if (leaveFraction > 0) {
                    if (isPaidLeave) paidLeaveDays += leaveFraction;
                    else if (isUnpaidLeave) unpaidLeaveDays += leaveFraction;
                    console.log(` ${leaveFraction} ${isPaidLeave ? 'PAID' : 'UNPAID'} leave added`);
                }
                continue;
            }

            if (penalisationPolicy.missingClockOutPenaltyType === ENUMS.missingClockOutPenaltyType.AMOUNT) {
                missingClockOutPenaltyAmount += (penalisationPolicy.missingClockOutPenaltyAmount || 0);
                presentDays += availableDay;
                console.log(` Amount penalty: ${penalisationPolicy.missingClockOutPenaltyAmount} - ${availableDay} present`);
            } else if (penalisationPolicy.missingClockOutPenaltyType === ENUMS.missingClockOutPenaltyType.LEAVE) {
                const dayType = penalisationPolicy.missingClockOutDayType || ENUMS.leaveType.FULL;
                const leaveType = penalisationPolicy.missingClockOutLeaveType || ENUMS.leavePolicyType.unpaidLeave;
                const isPenaltyPaid = (leaveType === ENUMS.leavePolicyType.paidLeave);

                if (dayType === ENUMS.leaveType.FULL) {
                    if (isPenaltyPaid) paidLeaveDays += availableDay;
                    else unpaidLeaveDays += availableDay;
                    console.log(` Full ${isPenaltyPaid ? 'PAID' : 'UNPAID'} leave penalty: ${availableDay}`);
                } else {
                    const penaltyAmount = Math.min(0.5, availableDay);
                    const remaining = availableDay - penaltyAmount;
                    
                    presentDays += remaining;
                    if (isPenaltyPaid) paidLeaveDays += penaltyAmount;
                    else unpaidLeaveDays += penaltyAmount;
                    console.log(` Half ${isPenaltyPaid ? 'PAID' : 'UNPAID'} penalty: ${penaltyAmount}, ${remaining} present`);
                }
            }

            if (leaveFraction > 0) {
                if (isPaidLeave) paidLeaveDays += leaveFraction;
                else if (isUnpaidLeave) unpaidLeaveDays += leaveFraction;
                console.log(` Original ${leaveFraction} ${isPaidLeave ? 'PAID' : 'UNPAID'} leave added`);
            }
            continue;
        }

        // Full day leave
        if (leaveFraction === 1) {
            if (isPaidLeave) paidLeaveDays += 1;
            else if (isUnpaidLeave) unpaidLeaveDays += 1;
            else absentDays += 1;
            console.log(" Full day leave");
            continue;
        }

        // Half day leave with no attendance
        if (leaveFraction === 0.5 && (!attendanceForDay || !attendanceForDay.clockIn)) {
            if (isPaidLeave) paidLeaveDays += 0.5;
            else if (isUnpaidLeave) unpaidLeaveDays += 0.5;
            absentDays += 0.5;
            console.log(" 0.5 leave + 0.5 absent");
            continue;
        }

        // No attendance, no leave
        if ((!attendanceForDay || !attendanceForDay.clockIn) && leaveFraction === 0) {
            absentDays += 1;
            console.log(" No attendance - 1 absent");
            continue;
        }

        // Add half day leave
        if (leaveFraction === 0.5) {
            if (isPaidLeave) paidLeaveDays += 0.5;
            else if (isUnpaidLeave) unpaidLeaveDays += 0.5;
            console.log(" 0.5 leave recorded, processing 0.5 attendance...");
        }

        const availableAttendance = leaveFraction === 0.5 ? 0.5 : 1;
        console.log(` Available attendance: ${availableAttendance}`);

        const hasLateIn = attendanceForDay.islateIn && penalisationPolicy?.enableLatePolicy;
        const hasEarlyOut = attendanceForDay.isEarlyOut && penalisationPolicy?.enableEarlyOutPolicy;

        let applyLateInPenalty = false;
        let applyEarlyOutPenalty = false;

        if (hasLateIn && hasEarlyOut) {
            console.log(` Both Late & Early - Rule: ${penaltyRule}`);
            switch (penaltyRule) {
                case 1:
                case 2:
                    applyLateInPenalty = true;
                    break;
                case 3:
                    applyEarlyOutPenalty = true;
                    break;
                case 4:
                default:
                    applyLateInPenalty = true;
                    applyEarlyOutPenalty = true;
                    break;
            }
        } else {
            applyLateInPenalty = hasLateIn;
            applyEarlyOutPenalty = hasEarlyOut;
        }

        let remainingAttendance = availableAttendance;

        // Late penalty
        if (applyLateInPenalty) {
            console.log(" Late penalty...");

            if (penalisationPolicy.applyInstantPenaltyForLateIn) {
                if (penalisationPolicy.instantLateInPenaltyType === ENUMS.instantPenaltyType.AMOUNT) {
                    instantLateInPenaltyAmount += (penalisationPolicy.instantLateInPenaltyAmount || 0);
                    console.log(`   Instant AMOUNT: ${penalisationPolicy.instantLateInPenaltyAmount}`);
                } else if (penalisationPolicy.instantLateInPenaltyType === ENUMS.instantPenaltyType.LEAVE) {
                    const dayType = penalisationPolicy.instantLateInDayType || ENUMS.leaveType.SECONDHALF;
                    const leaveType = penalisationPolicy.instantLateInLeaveType || ENUMS.leavePolicyType.unpaidLeave;
                    const isPaid = (leaveType === ENUMS.leavePolicyType.paidLeave);

                    if (dayType === ENUMS.leaveType.FULL) {
                        if (isPaid) paidLeaveDays += remainingAttendance;
                        else unpaidLeaveDays += remainingAttendance;
                        console.log(`   Instant FULL ${isPaid ? 'PAID' : 'UNPAID'}: ${remainingAttendance}`);
                        remainingAttendance = 0;
                    } else {
                        const halfDayPenalty = Math.min(0.5, remainingAttendance);
                        if (isPaid) paidLeaveDays += halfDayPenalty;
                        else unpaidLeaveDays += halfDayPenalty;
                        remainingAttendance -= halfDayPenalty;
                        console.log(`   Instant HALF ${isPaid ? 'PAID' : 'UNPAID'}: ${halfDayPenalty}`);
                    }
                }
            } else {
                totalLateCount++;
                console.log(`   Counter: ${totalLateCount}`);
            }
        }

        // Early out penalty
        if (applyEarlyOutPenalty && remainingAttendance > 0) {
            console.log(" Early Out penalty...");

            if (penalisationPolicy.applyInstantPenaltyForEarlyOut) {
                if (penalisationPolicy.instantEarlyOutPenaltyType === ENUMS.instantPenaltyType.AMOUNT) {
                    instantEarlyOutPenaltyAmount += (penalisationPolicy.instantEarlyOutPenaltyAmount || 0);
                    console.log(`   Instant AMOUNT: ${penalisationPolicy.instantEarlyOutPenaltyAmount}`);
                } else if (penalisationPolicy.instantEarlyOutPenaltyType === ENUMS.instantPenaltyType.LEAVE) {
                    const dayType = penalisationPolicy.instantEarlyOutDayType || ENUMS.leaveType.SECONDHALF;
                    const leaveType = penalisationPolicy.instantEarlyOutLeaveType || ENUMS.leavePolicyType.unpaidLeave;
                    const isPaid = (leaveType === ENUMS.leavePolicyType.paidLeave);

                    if (dayType === ENUMS.leaveType.FULL) {
                        if (isPaid) paidLeaveDays += remainingAttendance;
                        else unpaidLeaveDays += remainingAttendance;
                        console.log(`   Instant FULL ${isPaid ? 'PAID' : 'UNPAID'}: ${remainingAttendance}`);
                        remainingAttendance = 0;
                    } else {
                        const halfDayPenalty = Math.min(0.5, remainingAttendance);
                        if (isPaid) paidLeaveDays += halfDayPenalty;
                        else unpaidLeaveDays += halfDayPenalty;
                        remainingAttendance -= halfDayPenalty;
                        console.log(`   Instant HALF ${isPaid ? 'PAID' : 'UNPAID'}: ${halfDayPenalty}`);
                    }
                }
            } else {
                totalEarlyOutCount++;

                const earlyOutSeconds = Number(attendanceForDay.EarlyOutDuration || 0);
                const graceSeconds = (penalisationPolicy.earlyOutGraceMinutes || 0) * 60;

                let deductionSeconds = paySchedule.payForEarlyOutWithinGrace
                    ? Math.max(0, earlyOutSeconds - graceSeconds)
                    : earlyOutSeconds;

                const timeBasedDeductionDays = Math.min(deductionSeconds / shiftSeconds, remainingAttendance);
                earlyOutTimeDeductionDays += timeBasedDeductionDays;

                console.log(`   Counter: ${totalEarlyOutCount}, time deduction: ${timeBasedDeductionDays.toFixed(2)}`);

                if (timeBasedDeductionDays >= 0.5) {
                    const absenceAmount = Math.min(0.5, remainingAttendance);
                    remainingAttendance -= absenceAmount;
                    absentDays += absenceAmount;
                    console.log(`   Time >= 0.5 - ${absenceAmount} absent`);
                }
            }
        }

        presentDays += remainingAttendance;
        console.log(` Final: ${remainingAttendance} present`);

        // Overtime
        if (attendanceForDay.ExtraTime > 0 && paySchedule.payForExtraTime && overtimePolicy) {
            console.log(" Overtime...");
            const extraSeconds = Number(attendanceForDay.ExtraTime || 0);
            const perSecondSalary = Number(perDaySalary) / (Number(shiftHours) * 3600);
            otSecondsWorking += extraSeconds;

            if (overtimePolicy.payFactorType === ENUMS.payFactorType.MULTIPLIER) {
                const multiplier = overtimePolicy.workingMultiplier ?? 0.5;
                const otAmount = extraSeconds * perSecondSalary * multiplier;
                totalOvertimeAmount += otAmount;
                console.log(`   ${extraSeconds}s * ${perSecondSalary.toFixed(4)} * ${multiplier} = ${otAmount.toFixed(2)}`);
            } else if (overtimePolicy.payFactorType === ENUMS.payFactorType.FIXED_TOTAL) {
                const perSecondFixed = (overtimePolicy.fixedTotal || 0) / 3600;
                const otAmount = extraSeconds * perSecondFixed;
                totalOvertimeAmount += otAmount;
                console.log(`   ${extraSeconds}s * ${perSecondFixed.toFixed(2)} = ${otAmount.toFixed(2)}`);
            }
        }
    }

    console.log("\n\n=== COUNTER PENALTIES ===");
    if (penalisationPolicy?.enableSalaryDeduction) {
        if (penalisationPolicy.enableLatePolicy && !penalisationPolicy.applyInstantPenaltyForLateIn) {
            const lateAllowed = penalisationPolicy.lateAllowedPerMonth || 3;
            const lateToHalfDay = penalisationPolicy.lateToHalfDay || 2;
            const penalizableLates = Math.max(0, totalLateCount - lateAllowed);

            if (penalizableLates > 0 && lateToHalfDay > 0) {
                const lateHalfDays = Math.floor(penalizableLates / lateToHalfDay) * 0.5;
                penaltyDeductionDays += lateHalfDays;
                console.log(`Late: ${totalLateCount}, allowed: ${lateAllowed} â†’ deduct ${lateHalfDays}`);
            }
        }

        if (penalisationPolicy.enableEarlyOutPolicy && !penalisationPolicy.applyInstantPenaltyForEarlyOut) {
            const earlyOutToHalfDay = penalisationPolicy.earlyOutToHalfDay || 2;

            if (totalEarlyOutCount > 0 && earlyOutToHalfDay > 0) {
                const earlyOutHalfDays = Math.floor(totalEarlyOutCount / earlyOutToHalfDay) * 0.5;
                penaltyDeductionDays += earlyOutHalfDays;
                console.log(`Early Out: ${totalEarlyOutCount} â†’ deduct ${earlyOutHalfDays}`);
            }
        }
    }

    console.log("\n\n=== FINAL CALCULATION ===");

    const totalAccounted = presentDays + absentDays + paidLeaveDays + unpaidLeaveDays;
    
    console.log("\n ATTENDANCE:");
    console.log(`Working days: ${totalWorkingDays}`);
    console.log(`Present: ${presentDays.toFixed(2)}`);
    console.log(`Absent: ${absentDays.toFixed(2)}`);
    console.log(`Paid leave: ${paidLeaveDays.toFixed(2)}`);
    console.log(`Unpaid leave: ${unpaidLeaveDays.toFixed(2)}`);
    console.log(`Weekends: ${countWeekends}`);
    console.log(`Holidays: ${countHolidays}`);
    console.log(`\n Total: ${totalAccounted.toFixed(2)} / ${totalWorkingDays}`);
    
    if (totalAccounted > totalWorkingDays + 0.01) {
        console.warn(` WARNING: Total (${totalAccounted.toFixed(2)}) > working days (${totalWorkingDays})!`);
    }

    console.log("\n DEDUCTIONS:");
    console.log(`Early out time: ${earlyOutTimeDeductionDays.toFixed(2)} days`);
    console.log(`Counter penalty: ${penaltyDeductionDays.toFixed(2)} days`);
    console.log(`Missing clock out: ${missingClockOutPenaltyAmount.toFixed(2)}`);
    console.log(`Instant late: ${instantLateInPenaltyAmount.toFixed(2)}`);
    console.log(`Instant early out: ${instantEarlyOutPenaltyAmount.toFixed(2)}`);

    console.log("\n OVERTIME:");
    console.log(`Total: ${totalOvertimeAmount.toFixed(2)}`);

    const payableDays = presentDays + paidLeaveDays
        + (paySchedule.payForWeekends ? countWeekends : 0)
        + (paySchedule.payForHolidays ? countHolidays : 0);

    const totalUnpaidDays = earlyOutTimeDeductionDays + penaltyDeductionDays;
    const totalAmountPenalties = missingClockOutPenaltyAmount + instantLateInPenaltyAmount + instantEarlyOutPenaltyAmount;
    const unpaidDeduction = (perDaySalary * totalUnpaidDays) + totalAmountPenalties;

    const grossEarnings = (perDaySalary * payableDays) + totalOvertimeAmount - unpaidDeduction;

    console.log("\nSALARY:");
    console.log(`Per day: ${perDaySalary.toFixed(2)}`);
    console.log(`Payable days: ${payableDays.toFixed(2)}`);
    console.log(`Unpaid days: ${totalUnpaidDays.toFixed(2)}`);
    console.log(`Amount penalties: ${totalAmountPenalties.toFixed(2)}`);
    console.log(`Unpaid deduction: ${unpaidDeduction.toFixed(2)}`);
    console.log(`Gross earnings: ${grossEarnings.toFixed(2)}`);

    return {
        totalWorkingDays,
        countWeekends,
        countHolidays,
        presentDays: Number(presentDays.toFixed(2)),
        absentDays: Number(absentDays.toFixed(2)),
        paidLeaveDays: Number(paidLeaveDays.toFixed(2)),
        unpaidLeaveDays: Number(unpaidLeaveDays.toFixed(2)),

        earlyOutTimeDeductionDays: Number(earlyOutTimeDeductionDays.toFixed(2)),

        totalLateCount,
        totalEarlyOutCount,
        totalMissingClockOutCount,

        penaltyDeductionDays: Number(penaltyDeductionDays.toFixed(2)),
        missingClockOutPenaltyAmount: Number(missingClockOutPenaltyAmount.toFixed(2)),
        instantLateInPenaltyAmount: Number(instantLateInPenaltyAmount.toFixed(2)),
        instantEarlyOutPenaltyAmount: Number(instantEarlyOutPenaltyAmount.toFixed(2)),
        
        perDaySalary: Number(perDaySalary.toFixed(2)),
        payableDays: Number(payableDays.toFixed(2)),
        totalUnpaidDays: Number(totalUnpaidDays.toFixed(2)),
        totalAmountPenalties: Number(totalAmountPenalties.toFixed(2)),
        unpaidDeduction: Number(unpaidDeduction.toFixed(2)),

        totalOvertimeSeconds: otSecondsWorking + otSecondsWeekend + otSecondsHoliday,
        totalOvertimeAmount: Number(totalOvertimeAmount.toFixed(2)),
        grossEarnings: Number(grossEarnings.toFixed(2))
    };
};

export default SalaryCalculationfunction;


//need changes 
// import User from "../models/auth.js";
// import Shift from "../models/Shift.js";
// import Attendance from "../models/Attendance.js";
// import Holiday from "../models/Holiday.js";
// import LeaveApplication from "../models/leaveApplication.js";
// import PaySchedule from "../models/paySchedule.js";
// import OvertimePolicy from "../models/overTimePolicy.js";
// import PenalisationPolicy from "../models/PenalisationPolicy.js";
// import { getUTCRangeForISTDate, sameDay } from "../utils/time.js";
// import { ENUMS } from "./constants.js";

// const SalaryCalculationfunction = async (userId, startDate, endDate, grossSalary) => {
//     if (!userId || !startDate || !endDate) throw new Error("userId, startDate and endDate are required");

//     // ============= DATA FETCHING (Parallel for Performance) =============
//     const [user, shift, holidays, leaveApplication, paySchedule, penalisationPolicy] = await Promise.all([
//         User.findById(userId),
//         Shift.findOne({ assignUsers: userId }),
//         Holiday.find({
//             assignUsers: userId,
//             $or: [{ startDate: { $lte: endDate }, endDate: { $gte: startDate } }],
//         }),
//         LeaveApplication.find({
//             userId,
//             status: ENUMS.statusType.APPROVED,
//             $or: [{ startDate: { $lte: endDate }, endDate: { $gte: startDate } }],
//         }).populate("leavePolicyId"),
//         PaySchedule.findOne({ locationId: (await User.findById(userId).select('locationId')).locationId }),
//         PenalisationPolicy.findOne({ locationId: (await User.findById(userId).select('locationId')).locationId })
//     ]);

//     if (!user) throw new Error("User not found");
//     if (!shift) throw new Error("User not assigned to any shift");
//     if (!paySchedule) throw new Error("PaySchedule not found for user's location");

//     let overtimePolicy = null;
//     if (user.assignedOvertimePolicy) {
//         overtimePolicy = await OvertimePolicy.findById(user.assignedOvertimePolicy).lean();
//     }

//     // ============= PREPARE DATE RANGE & HOLIDAY MAP =============
//     const startIST = new Date(new Date(startDate).getTime() + 5.5 * 60 * 60 * 1000);
//     const endIST = new Date(endDate.getTime());

//     // Create holiday lookup map for O(1) access
//     const holidayMap = new Map();
//     holidays.forEach(h => {
//         const hStart = h.startDate;
//         const hEnd = h.endDate;
//         for (let t = hStart.getTime(); t <= hEnd.getTime(); t += 24 * 60 * 60 * 1000) {
//             const dateKey = new Date(t).toISOString().split('T')[0];
//             holidayMap.set(dateKey, h);
//         }
//     });

//     // ============= FETCH EXISTING ATTENDANCE & CREATE MISSING RECORDS =============
//     const existingAttendance = await Attendance.find({
//         userId,
//         date: { $gte: startDate, $lte: endDate }
//     }).lean();

//     // Create attendance lookup map
//     const attendanceMap = new Map();
//     existingAttendance.forEach(att => {
//         const dateKey = new Date(att.date).toISOString().split('T')[0];
//         attendanceMap.set(dateKey, att);
//     });

//     // Prepare attendance records to be created
//     const attendanceToCreate = [];
    
//     for (let cur = startIST.getTime(); cur <= endIST.getTime(); cur += 24 * 60 * 60 * 1000) {
//         const curDate = new Date(cur);
//         const y = curDate.getUTCFullYear();
//         const m = curDate.getUTCMonth() + 1;
//         const d = curDate.getUTCDate();
        
//         const { startUTC, endUTC } = getUTCRangeForISTDate(y, m, d);

//                 const dateKey = startUTC.toISOString().split('T')[0];
//                 console.log("datekey" , dateKey)
//         // Skip if attendance already exists
//         if (attendanceMap.has(dateKey)) continue;
        
//         // Determine dayStatus
//         const dayOfWeek = new Date(Date.UTC(y, m - 1, d)).getUTCDay();
//         const shiftDay = shift.days.get(String(dayOfWeek));
        
//         let dayStatus = ENUMS.DAY_STATUS.WORKING; // Default
        
//         // Check if holiday first
//         if (holidayMap.has(dateKey)) {
//             dayStatus = ENUMS.DAY_STATUS.HOLIDAY;
//         } else if (shiftDay) {
//             // Use shift's configured dayStatus
//             dayStatus = shiftDay.dayStatus;
//         }
        
//         // Create attendance record
//         attendanceToCreate.push({
//             userId,
//             shiftId :shift._id,
//             date: startUTC,
//             dayStatus,
//             clockIn: null,
//             clockOut: null,
//             totalWorkingTime: 0,
//             ExtraTime: 0,
//             islateIn: false,
//             isEarlyOut: false,
//             EarlyOutDuration: 0,
//             autoGenerated: true // Flag to identify auto-generated records
//         });
//     }

//     // Bulk insert missing attendance records
//     if (attendanceToCreate.length > 0) {
//         await Attendance.insertMany(attendanceToCreate);
//         console.log(` Created ${attendanceToCreate.length} missing attendance records`);
        
//         // Add newly created records to map
//         attendanceToCreate.forEach(att => {
//             const dateKey = new Date(att.date).toISOString().split('T')[0];
//             attendanceMap.set(dateKey, att);
//         });
//     }

//     const dayInfos = [];
//     let totalWorkingDays = 0, countWeekends = 0, countHolidays = 0;
//     let presentDays = 0, absentDays = 0, paidLeaveDays = 0, unpaidLeaveDays = 0;
//     let otSecondsWorking = 0, otSecondsWeekend = 0, otSecondsHoliday = 0;
//     let totalOvertimeAmount = 0;
//     let totalLateCount = 0, totalEarlyOutCount = 0, totalMissingClockOutCount = 0;
//     let earlyOutTimeDeductionDays = 0, penaltyDeductionDays = 0;
//     let missingClockOutPenaltyAmount = 0, instantLateInPenaltyAmount = 0, instantEarlyOutPenaltyAmount = 0;

//     const penaltyRule = penalisationPolicy?.penaltyRuleForLateWithEarlyOut || ENUMS.penaltyRuleType.BOTH;

//     for (let cur = startIST.getTime(); cur <= endIST.getTime(); cur += 24 * 60 * 60 * 1000) {
//         const curDate = new Date(cur);
//         const y = curDate.getUTCFullYear();
//         const m = curDate.getUTCMonth() + 1;
//         const d = curDate.getUTCDate();

//         const { startUTC, endUTC } = getUTCRangeForISTDate(y, m, d);
//         const dateKey = startUTC.toISOString().split('T')[0];
//         const dayOfWeek = new Date(Date.UTC(y, m - 1, d)).getUTCDay();
//         const shiftDay = shift.days.get(String(dayOfWeek));

//         // Get attendance from map
//         const attendanceForDay = attendanceMap.get(dateKey) || null;
        
//         let isHoliday, isWeekend;
        
//         if (attendanceForDay) {
//             // If attendance exists, use its dayStatus (single source of truth)
//             isHoliday = attendanceForDay.dayStatus === ENUMS.DAY_STATUS.HOLIDAY;
//             isWeekend = attendanceForDay.dayStatus === ENUMS.DAY_STATUS.WEEKEND;
//         }
        
//         const shiftHours = (shiftDay?.dayStatus === ENUMS.DAY_STATUS.FIRSTHALF || 
//                            shiftDay?.dayStatus === ENUMS.DAY_STATUS.SECONDHALF)
//             ? (shift.halfDayHrs || 5)
//             : (shift.fullDayHrs || 8);

//         const shiftSeconds = shiftHours * 3600;

//         console.log(`\n=== ${dateKey} (${isWeekend ? 'WEEKEND' : isHoliday ? 'HOLIDAY' : 'WORKING'}) ===`);

//         // Store day info
//         dayInfos.push({ 
//             startUTC, endUTC, isWeekend, isHoliday, shiftHours, shiftDay, attendanceForDay,
//             type: isWeekend ? 'WEEKEND' : isHoliday ? 'HOLIDAY' : 'WORKING'
//         });

//         // Count day types
//         if (isWeekend) {
//             countWeekends++;
//             continue
//         } else if (isHoliday) {
//             countHolidays++;
//             continue;
//         } else {
//             totalWorkingDays++;
//         }

//         if (isWeekend || isHoliday) {
//             if (attendanceForDay?.clockIn && attendanceForDay.ExtraTime > 0 && paySchedule.payForExtraTime && overtimePolicy) {
//                 console.log(`${isHoliday ? 'HOLIDAY' : 'WEEKEND'} overtime detected`);
//                 const extraSeconds = Number(attendanceForDay.ExtraTime || 0);
//                 const perDaySalary = grossSalary / Math.max(totalWorkingDays || 1, 1);
//                 const perSecondSalary = perDaySalary / (shiftHours * 3600);
//                 console.log("")

//                 if (isHoliday) otSecondsHoliday += extraSeconds;
//                 else otSecondsWeekend += extraSeconds;

//                 if (overtimePolicy.payFactorType === ENUMS.payFactorType.MULTIPLIER) {
//                     const multiplier = isHoliday
//                         ? (overtimePolicy.holidayMultiplier ?? 1.5)
//                         : (overtimePolicy.weekendMultiplier ?? 1);
//                     totalOvertimeAmount += extraSeconds * perSecondSalary * multiplier;
//                     console.log(`OT: ${extraSeconds}s * â‚¹${perSecondSalary.toFixed(4)} * ${multiplier} = â‚¹${(extraSeconds * perSecondSalary * multiplier).toFixed(2)}`);
//                 } else if (overtimePolicy.payFactorType === ENUMS.payFactorType.FIXED_TOTAL) {
//                     const perSecondFixed = (overtimePolicy.fixedTotal || 0) / 3600;
//                     totalOvertimeAmount += extraSeconds * perSecondFixed;
//                     console.log(`OT: ${extraSeconds}s * â‚¹${perSecondFixed.toFixed(2)} = â‚¹${(extraSeconds * perSecondFixed).toFixed(2)}`);
//                 }
//             }
//             continue; // Skip to next day
//         }


//         // Check for leave
//         let leaveFraction = 0, isPaidLeave = false, isUnpaidLeave = false;
//         for (let lp of leaveApplication) {
//             const policy = lp.leavePolicyId;
//             const leaveDay = lp.leaveDays.find(ld => sameDay(ld.date, startUTC));
//             if (leaveDay) {
//                 leaveFraction = leaveDay.leaveType === ENUMS.leaveType.FULL ? 1 : 0.5;
//                 if (policy.policyType === ENUMS.leavePolicyType.paidLeave) isPaidLeave = true;
//                 else if (policy.policyType === ENUMS.leavePolicyType.unpaidLeave) isUnpaidLeave = true;
//                 console.log(`Leave: ${leaveFraction} day, ${isPaidLeave ? 'PAID' : isUnpaidLeave ? 'UNPAID' : 'ABSENT'}`);
//                 break;
//             }
//         }

//         // ============= MISSING CLOCK OUT HANDLING =============
//         if (attendanceForDay?.clockIn && !attendanceForDay.clockOut) {
//             totalMissingClockOutCount++;
//             console.log("âš ï¸ Missing clock out");

//             if (!penalisationPolicy?.enableMissingClockOutPenalty) {
//                 absentDays += 1;
//                 console.log("No policy â†’ 1 day absent");
//                 continue;
//             }

//             if (penalisationPolicy.missingClockOutPenaltyType === ENUMS.missingClockOutPenaltyType.AMOUNT) {
//                 missingClockOutPenaltyAmount += (penalisationPolicy.missingClockOutPenaltyAmount || 0);
//                 presentDays += 1;
//                 console.log(`Amount penalty: â‚¹${penalisationPolicy.missingClockOutPenaltyAmount}`);
//             } else if (penalisationPolicy.missingClockOutPenaltyType === ENUMS.missingClockOutPenaltyType.LEAVE) {
//                 const dayType = penalisationPolicy.missingClockOutDayType || ENUMS.leaveType.FULL;
//                 const leaveType = penalisationPolicy.missingClockOutLeaveType || ENUMS.leavePolicyType.unpaidLeave;
//                 const isPaid = (leaveType === ENUMS.leavePolicyType.paidLeave);

//                 if (dayType === ENUMS.leaveType.FULL) {
//                     if (isPaid) paidLeaveDays += 1;
//                     else unpaidLeaveDays += 1;
//                     console.log(`Full day ${isPaid ? 'PAID' : 'UNPAID'} leave penalty`);
//                 } else {
//                     presentDays += 0.5;
//                     if (isPaid) paidLeaveDays += 0.5;
//                     else unpaidLeaveDays += 0.5;
//                     console.log(`Half day ${isPaid ? 'PAID' : 'UNPAID'} leave + 0.5 present`);
//                 }
//             }
//             continue;
//         }

//         // ============= FULL DAY LEAVE =============
//         if (leaveFraction === 1) {
//             if (isPaidLeave) paidLeaveDays += 1;
//             else if (isUnpaidLeave) unpaidLeaveDays += 1;
//             else absentDays += 1;
//             console.log("Full day leave");
//             continue;
//         }

//         // ============= HALF DAY LEAVE WITHOUT ATTENDANCE =============
//         if (leaveFraction === 0.5 && !attendanceForDay?.clockIn) {
//             if (isPaidLeave) paidLeaveDays += 0.5;
//             else if (isUnpaidLeave) unpaidLeaveDays += 0.5;
//             absentDays += 0.5;
//             console.log("Half leave + 0.5 absent (no attendance)");
//             continue;
//         }

//         // ============= NO ATTENDANCE, NO LEAVE =============
//         if (!attendanceForDay?.clockIn && leaveFraction === 0) {
//             absentDays += 1;
//             console.log("No attendance, no leave â†’ 1 day absent");
//             continue;
//         }

//         // ============= ATTENDANCE + POSSIBLE HALF LEAVE =============
//         if (leaveFraction === 0.5) {
//             if (isPaidLeave) paidLeaveDays += 0.5;
//             else if (isUnpaidLeave) unpaidLeaveDays += 0.5;
//             console.log("Half leave recorded");
//         }

//         const availableAttendance = leaveFraction === 0.5 ? 0.5 : 1;
//         console.log(`Processing ${availableAttendance} day attendance...`);

//         const hasLateIn = attendanceForDay?.islateIn && penalisationPolicy?.enableLatePolicy;
//         const hasEarlyOut = attendanceForDay?.isEarlyOut && penalisationPolicy?.enableEarlyOutPolicy;

//         let applyLateInPenalty = false, applyEarlyOutPenalty = false;

//         // ============= PENALTY RULE APPLICATION =============
//         if (hasLateIn && hasEarlyOut) {
//             console.log(`Both violations - Rule: ${penaltyRule}`);
//             switch (penaltyRule) {
//                 case 1:
//                 case 2:
//                     applyLateInPenalty = true;
//                     console.log("â†’ ONLY Late In");
//                     break;
//                 case 3:
//                     applyEarlyOutPenalty = true;
//                     console.log("â†’ ONLY Early Out");
//                     break;
//                 case 4:
//                 default:
//                     applyLateInPenalty = applyEarlyOutPenalty = true;
//                     console.log("â†’ BOTH penalties");
//                     break;
//             }
//         } else {
//             applyLateInPenalty = hasLateIn;
//             applyEarlyOutPenalty = hasEarlyOut;
//             if (hasLateIn) console.log("â° Late In");
//             if (hasEarlyOut) console.log("ðŸƒ Early Out");
//         }

//         let remainingAttendance = availableAttendance;

//         // ============= LATE IN PENALTY =============
//         if (applyLateInPenalty) {
//             console.log("Processing Late In...");

//             if (penalisationPolicy.applyInstantPenaltyForLateIn) {
//                 if (penalisationPolicy.instantLateInPenaltyType === ENUMS.instantPenaltyType.AMOUNT) {
//                     instantLateInPenaltyAmount += (penalisationPolicy.instantLateInPenaltyAmount || 0);
//                     console.log(`  â‚¹${penalisationPolicy.instantLateInPenaltyAmount} penalty`);
//                 } else if (penalisationPolicy.instantLateInPenaltyType === ENUMS.instantPenaltyType.LEAVE) {
//                     const dayType = penalisationPolicy.instantLateInDayType || ENUMS.leaveType.SECONDHALF;
//                     const leaveType = penalisationPolicy.instantLateInLeaveType || ENUMS.leavePolicyType.unpaidLeave;
//                     const isPaid = (leaveType === ENUMS.leavePolicyType.paidLeave);

//                     if (dayType === ENUMS.leaveType.FULL) {
//                         if (isPaid) paidLeaveDays += remainingAttendance;
//                         else unpaidLeaveDays += remainingAttendance;
//                         console.log(`  Full ${isPaid ? 'paid' : 'unpaid'} leave: ${remainingAttendance}`);
//                         remainingAttendance = 0;
//                     } else {
//                         const halfDayPenalty = Math.min(0.5, remainingAttendance);
//                         if (isPaid) paidLeaveDays += halfDayPenalty;
//                         else unpaidLeaveDays += halfDayPenalty;
//                         remainingAttendance -= halfDayPenalty;
//                         console.log(`  Half ${isPaid ? 'paid' : 'unpaid'} leave: ${halfDayPenalty} (rem: ${remainingAttendance})`);
//                     }
//                 }
//             } else {
//                 totalLateCount++;
//                 console.log(`  Counter: ${totalLateCount}`);
//             }
//         }

//         // ============= EARLY OUT PENALTY =============
//         if (applyEarlyOutPenalty && remainingAttendance > 0) {
//             console.log("Processing Early Out...");

//             if (penalisationPolicy.applyInstantPenaltyForEarlyOut) {
//                 if (penalisationPolicy.instantEarlyOutPenaltyType === ENUMS.instantPenaltyType.AMOUNT) {
//                     instantEarlyOutPenaltyAmount += (penalisationPolicy.instantEarlyOutPenaltyAmount || 0);
//                     console.log(`  â‚¹${penalisationPolicy.instantEarlyOutPenaltyAmount} penalty`);
//                 } else if (penalisationPolicy.instantEarlyOutPenaltyType === ENUMS.instantPenaltyType.LEAVE) {
//                     const dayType = penalisationPolicy.instantEarlyOutDayType || ENUMS.leaveType.SECONDHALF;
//                     const leaveType = penalisationPolicy.instantEarlyOutLeaveType || ENUMS.leavePolicyType.unpaidLeave;
//                     const isPaid = (leaveType === ENUMS.leavePolicyType.paidLeave);

//                     if (dayType === ENUMS.leaveType.FULL) {
//                         if (isPaid) paidLeaveDays += remainingAttendance;
//                         else unpaidLeaveDays += remainingAttendance;
//                         console.log(`  Full ${isPaid ? 'paid' : 'unpaid'} leave: ${remainingAttendance}`);
//                         remainingAttendance = 0;
//                     } else {
//                         const halfDayPenalty = Math.min(0.5, remainingAttendance);
//                         if (isPaid) paidLeaveDays += halfDayPenalty;
//                         else unpaidLeaveDays += halfDayPenalty;
//                         remainingAttendance -= halfDayPenalty;
//                         console.log(`  Half ${isPaid ? 'paid' : 'unpaid'} leave: ${halfDayPenalty} (rem: ${remainingAttendance})`);
//                     }
//                 }
//             } else {
//                 totalEarlyOutCount++;

//                 const earlyOutSeconds = Number(attendanceForDay.EarlyOutDuration || 0);
//                 const graceSeconds = (penalisationPolicy.earlyOutGraceMinutes || 0) * 60;

//                 let deductionSeconds = paySchedule.payForEarlyOutWithinGrace
//                     ? Math.max(0, earlyOutSeconds - graceSeconds)
//                     : earlyOutSeconds;

//                 const timeBasedDeductionDays = Math.min(deductionSeconds / shiftSeconds, remainingAttendance);
//                 earlyOutTimeDeductionDays += timeBasedDeductionDays;

//                 console.log(`  Counter: ${totalEarlyOutCount}, time deduction: ${timeBasedDeductionDays.toFixed(2)}`);

//                 if (timeBasedDeductionDays >= 0.5) {
//                     const absenceAmount = Math.min(0.5, remainingAttendance);
//                     remainingAttendance -= absenceAmount;
//                     absentDays += absenceAmount;
//                     console.log(`  ${absenceAmount} day marked absent`);
//                 }
//             }
//         }

//         presentDays += remainingAttendance;
//         console.log(`âœ… ${remainingAttendance} day present`);

//         // ============= WORKING DAY OVERTIME =============
//         if (attendanceForDay?.ExtraTime > 0 && paySchedule.payForExtraTime && overtimePolicy) {
//             const extraSeconds = Number(attendanceForDay.ExtraTime || 0);
//             const perDaySalary = grossSalary / totalWorkingDays;
//             const perSecondSalary = perDaySalary / (shiftHours * 3600);
//             otSecondsWorking += extraSeconds;

//             if (overtimePolicy.payFactorType === ENUMS.payFactorType.MULTIPLIER) {
//                 const multiplier = overtimePolicy.workingMultiplier ?? 0.5;
//                 const otAmount = extraSeconds * perSecondSalary * multiplier;
//                 totalOvertimeAmount += otAmount;
//                 console.log(`ðŸ’° OT: ${extraSeconds}s * â‚¹${perSecondSalary.toFixed(4)} * ${multiplier} = â‚¹${otAmount.toFixed(2)}`);
//             } else if (overtimePolicy.payFactorType === ENUMS.payFactorType.FIXED_TOTAL) {
//                 const perSecondFixed = (overtimePolicy.fixedTotal || 0) / 3600;
//                 const otAmount = extraSeconds * perSecondFixed;
//                 totalOvertimeAmount += otAmount;
//                 console.log(`ðŸ’° OT: ${extraSeconds}s * â‚¹${perSecondFixed.toFixed(2)} = â‚¹${otAmount.toFixed(2)}`);
//             }
//         }
//     }

//     // ============= COUNTER-BASED PENALTY PROCESSING =============
//     console.log("\nðŸ“Š COUNTER-BASED PENALTIES");
//     if (penalisationPolicy?.enableSalaryDeduction) {
//         if (penalisationPolicy.enableLatePolicy && !penalisationPolicy.applyInstantPenaltyForLateIn) {
//             const lateAllowed = penalisationPolicy.lateAllowedPerMonth || 3;
//             const lateToHalfDay = penalisationPolicy.lateToHalfDay || 2;
//             const penalizableLates = Math.max(0, totalLateCount - lateAllowed);

//             if (penalizableLates > 0 && lateToHalfDay > 0) {
//                 const lateHalfDays = Math.floor(penalizableLates / lateToHalfDay) * 0.5;
//                 penaltyDeductionDays += lateHalfDays;
//                 console.log(`Late: ${totalLateCount} total, ${lateAllowed} allowed â†’ ${lateHalfDays} days deducted`);
//             } else {
//                 console.log(`Late: ${totalLateCount} (within limit)`);
//             }
//         }

//         if (penalisationPolicy.enableEarlyOutPolicy && !penalisationPolicy.applyInstantPenaltyForEarlyOut) {
//             const earlyOutToHalfDay = penalisationPolicy.earlyOutToHalfDay || 2;

//             if (totalEarlyOutCount > 0 && earlyOutToHalfDay > 0) {
//                 const earlyOutHalfDays = Math.floor(totalEarlyOutCount / earlyOutToHalfDay) * 0.5;
//                 penaltyDeductionDays += earlyOutHalfDays;
//                 console.log(`Early Out: ${totalEarlyOutCount} â†’ ${earlyOutHalfDays} days deducted`);
//             }
//         }
//     }

//     // ============= FINAL SALARY CALCULATION =============
//     if (totalWorkingDays === 0) totalWorkingDays = 1;
//     const perDaySalary = grossSalary / totalWorkingDays;

//     console.log("\nðŸ’µ FINAL CALCULATION");
//     console.log(`Per day salary: â‚¹${perDaySalary.toFixed(2)}`);
//     console.log(`\nAttendance: P:${presentDays.toFixed(2)} A:${absentDays.toFixed(2)} PL:${paidLeaveDays.toFixed(2)} UL:${unpaidLeaveDays.toFixed(2)}`);
//     console.log(`Weekends: ${countWeekends}, Holidays: ${countHolidays}`);

//     const payableDays = presentDays + paidLeaveDays
//         + (paySchedule.payForWeekends ? countWeekends : 0)
//         + (paySchedule.payForHolidays ? countHolidays : 0);

//     const totalUnpaidDays = earlyOutTimeDeductionDays + penaltyDeductionDays;
//     const totalAmountPenalties = missingClockOutPenaltyAmount + instantLateInPenaltyAmount + instantEarlyOutPenaltyAmount;
//     const unpaidDeduction = (perDaySalary * totalUnpaidDays) + totalAmountPenalties;

//     const grossEarnings = (perDaySalary * payableDays) + totalOvertimeAmount - unpaidDeduction;

//     // Component breakdown
//     const basic = grossSalary * 0.5;
//     const HRA = basic * 0.4;
//     const DA = basic * 0.1;
//     const otherAllowances = grossSalary - (basic + HRA + DA);

//     const earnings = { basic, HRA, DA, otherAllowances, grossEarnings };

//     // Statutory deductions
//     const proratedBasic = (basic / totalWorkingDays) * payableDays;
//     const proratedDA = (DA / totalWorkingDays) * payableDays;

//     const pf = (proratedBasic + proratedDA) * 0.12;
//     const esi = grossEarnings <= 21000 ? grossEarnings * 0.0075 : 0;
//     const tax = grossEarnings > 25000 ? grossEarnings * 0.05 : 0;
//     const otherDeductions = 0;

//     const grossDeductions = pf + esi + tax;
//     const deductions = { pf, esi, tax, otherDeductions, grossDeductions };

//     const netSalary = Math.max(0, grossEarnings - grossDeductions);

//     console.log(`\nðŸ’° Net Salary: â‚¹${netSalary.toFixed(2)}`);

//     return {
//         totalWorkingDays,
//         countWeekends,
//         countHolidays,
//         presentDays: Number(presentDays.toFixed(2)),
//         absentDays: Number(absentDays.toFixed(2)),
//         paidLeaveDays: Number(paidLeaveDays.toFixed(2)),
//         unpaidLeaveDays: Number(unpaidLeaveDays.toFixed(2)),
//         earlyOutTimeDeductionDays: Number(earlyOutTimeDeductionDays.toFixed(2)),
//         totalLateCount,
//         totalEarlyOutCount,
//         totalMissingClockOutCount,
//         penaltyDeductionDays: Number(penaltyDeductionDays.toFixed(2)),
//         missingClockOutPenaltyAmount: Number(missingClockOutPenaltyAmount.toFixed(2)),
//         instantLateInPenaltyAmount: Number(instantLateInPenaltyAmount.toFixed(2)),
//         instantEarlyOutPenaltyAmount: Number(instantEarlyOutPenaltyAmount.toFixed(2)),
//         perDaySalary: Number(perDaySalary.toFixed(2)),
//         payableDays: Number(payableDays.toFixed(2)),
//         totalUnpaidDays: Number(totalUnpaidDays.toFixed(2)),
//         totalAmountPenalties: Number(totalAmountPenalties.toFixed(2)),
//         unpaidDeduction: Number(unpaidDeduction.toFixed(2)),
//         totalOvertimeSeconds: otSecondsWorking + otSecondsWeekend + otSecondsHoliday,
//         totalOvertimeAmount: Number(totalOvertimeAmount.toFixed(2)),
//         earnings,
//         deductions,
//         netSalary: Number(netSalary.toFixed(2))
//     };
// };

// export default SalaryCalculationfunction;




// current code is right code
// import User from "../models/auth.js";
// import Shift from "../models/Shift.js";
// import Attendance from "../models/Attendance.js";
// import Holiday from "../models/Holiday.js";
// import LeaveApplication from "../models/leaveApplication.js";
// import PaySchedule from "../models/paySchedule.js";
// import OvertimePolicy from "../models/overTimePolicy.js";
// import PenalisationPolicy from "../models/PenalisationPolicy.js";
// import { getUTCRangeForISTDate, sameDay } from "../utils/time.js";
// import { ENUMS } from "./constants.js";

// const SalaryCalculationfunction = async (userId, startDate, endDate, grossSalary) => {
//     if (!userId || !startDate || !endDate) throw new Error("userId, startDate and endDate are required");

//     const user = await User.findById(userId);
//     if (!user) throw new Error("User not found");

//     const shift = await Shift.findOne({ assignUsers: userId });
//     if (!shift) throw new Error("User not assigned to any shift");

//     const holidays = await Holiday.find({
//         assignUsers: userId,
//         $or: [{ startDate: { $lte: endDate }, endDate: { $gte: startDate } }],
//     });

//     const leaveApplication = await LeaveApplication.find({
//         userId,
//         status: ENUMS.statusType.APPROVED,
//         $or: [{ startDate: { $lte: endDate }, endDate: { $gte: startDate } }],
//     }).populate("leavePolicyId");

//     const attendance = await Attendance.find({
//         userId,
//         date: { $gte: startDate, $lte: endDate },
//         clockIn: { $ne: null },
//     });

//     const paySchedule = await PaySchedule.findOne({ locationId: user.locationId });
//     if (!paySchedule) throw new Error("PaySchedule not found for user's location");

//     const penalisationPolicy = await PenalisationPolicy.findOne({ locationId: user.locationId });

//     let overtimePolicy = null;
//     if (user.assignedOvertimePolicy) {
//         overtimePolicy = await OvertimePolicy.findById(user.assignedOvertimePolicy).lean();
//     }

//     const startIST = new Date(new Date(startDate).getTime() + 5.5 * 60 * 60 * 1000);
//     const endIST = new Date(endDate.getTime());

//     const dayInfos = [];
//     let totalWorkingDays = 0, countWeekends = 0, countHolidays = 0;

//     for (let cur = startIST.getTime(); cur <= endIST.getTime(); cur += 24 * 60 * 60 * 1000) {
//         const curDate = new Date(cur);
//         const y = curDate.getUTCFullYear();
//         const m = curDate.getUTCMonth() + 1;
//         const d = curDate.getUTCDate();

//         const { startUTC, endUTC } = getUTCRangeForISTDate(y, m, d);
//         const dayOfWeek = new Date(Date.UTC(y, m - 1, d)).getUTCDay();
//         const shiftDay = shift.days.get(String(dayOfWeek));

//         const isWeekend = shiftDay && shiftDay.dayStatus === ENUMS.DAY_STATUS.WEEKEND;
//         const isHoliday = holidays.some(h => startUTC <= h.endDate && endUTC >= h.startDate);
//         const shiftHours = (shiftDay?.dayStatus === ENUMS.DAY_STATUS.FIRSTHALF || shiftDay?.dayStatus === ENUMS.DAY_STATUS.SECONDHALF)
//             ? (shift.halfDayHrs || 5)
//             : (shift.fullDayHrs || 8);

//         const attendanceForDay = attendance.find(a => a.date >= startUTC && a.date <= endUTC) || null;

//         if (isWeekend) {
//             countWeekends++;
//             continue;
//         }
//         if (isHoliday) {
//             countHolidays++;
//             continue;
//         }
//         if (!isWeekend && !isHoliday) totalWorkingDays++;

//         dayInfos.push({ startUTC, endUTC, isWeekend, isHoliday, shiftHours, shiftDay, attendanceForDay, totalWorkingDays });
//     }

//     if (totalWorkingDays === 0) totalWorkingDays = 1;

//     const perDaySalary = grossSalary / totalWorkingDays;
//     console.log("perdaySalary", perDaySalary);

//     let presentDays = 0, absentDays = 0, paidLeaveDays = 0, unpaidLeaveDays = 0;
//     let otSecondsWorking = 0, otSecondsWeekend = 0, otSecondsHoliday = 0;
//     let totalOvertimeAmount = 0;

//     // PENALISATION TRACKING (ye sirf count ke liye hai, deduction alag hoga)
//     let totalLateCount = 0;
//     let totalEarlyOutCount = 0;
//     let totalMissingClockOutCount = 0;

//     // DEDUCTION TRACKING (actual paisa yahan se katega)
//     let earlyOutTimeDeductionDays = 0;  // Time-based early out deduction (from PaySchedule)
//     let penaltyDeductionDays = 0;        // Policy-based penalty deduction (from PenalisationPolicy)
//     let missingClockOutPenaltyAmount = 0; // Amount-based penalty for missing clock out

//     for (const dayInfo of dayInfos) {
//         const { startUTC, shiftHours, isWeekend, isHoliday, attendanceForDay } = dayInfo;

//         let leaveFraction = 0, isPaidLeave = false, isUnpaidLeave = false;

//         for (let lp of leaveApplication) {
//             const policy = lp.leavePolicyId;
//             const leaveDay = lp.leaveDays.find(ld => sameDay(ld.date, startUTC));
//             if (leaveDay) {
//                 leaveFraction = leaveDay.leaveType === ENUMS.leaveType.FULL ? 1 : 0.5;
//                 if (policy.policyType === ENUMS.leavePolicyType.paidLeave) isPaidLeave = true;
//                 else if (policy.policyType === ENUMS.leavePolicyType.unpaidLeave) isUnpaidLeave = true;
//                 break;
//             }
//         }
//         if (attendanceForDay && attendanceForDay.clockIn && !attendanceForDay.clockOut) {
//             totalMissingClockOutCount++;

//             let presentToAdd = 0;
//             let leaveToAdd = 0;
//             let isPaidLeaveType = false;

//             if (penalisationPolicy?.enableMissingClockOutPenalty) {

//                 if (penalisationPolicy.missingClockOutPenaltyType === ENUMS.missingClockOutPenaltyType.AMOUNT) {
//                     // Amount penalty - employee ko present count karo
//                     missingClockOutPenaltyAmount += (penalisationPolicy.missingClockOutPenaltyAmount || 0);
//                     presentToAdd = 1;

//                 } else if (penalisationPolicy.missingClockOutPenaltyType === ENUMS.missingClockOutPenaltyType.LEAVE) {
//                     const dayType = penalisationPolicy.missingClockOutDayType || ENUMS.leaveType.FULL;
//                     const leaveType = penalisationPolicy.missingClockOutLeaveType || ENUMS.leavePolicyType.unpaidLeave;
//                     isPaidLeaveType = (leaveType === ENUMS.leavePolicyType.paidLeave);

//                     // Determine deduction
//                     if (dayType === ENUMS.leaveType.FULL) {
//                         leaveToAdd = 1.0;
//                         presentToAdd = 0;
//                     } else {  // FIRST_HALF or SECOND_HALF
//                         leaveToAdd = 0.5;
//                         presentToAdd = 0.5;
//                     }
//                 }
//             } else {
//                 // No penalty policy - treat as absent
//                 absentDays += 1;
//                 continue;
//             }

//             presentDays += presentToAdd;

//             if (leaveToAdd > 0) {
//                 if (isPaidLeaveType) {
//                     paidLeaveDays += leaveToAdd;
//                 } else {
//                     unpaidLeaveDays += leaveToAdd;
//                 }
//             }

//             console.log(`Missing clock out: Present=${presentToAdd}, Leave=${leaveToAdd}, Paid=${isPaidLeaveType}`);
//             continue;
//         }

//         // Weekend/Holiday overtime calculation
//         if (isWeekend || isHoliday) {
//             if (attendanceForDay && attendanceForDay.ExtraTime > 0 && paySchedule.payForExtraTime && overtimePolicy) {
//                 console.log("under isweekend isholiday, and extratime");
//                 const extraSeconds = Number(attendanceForDay.ExtraTime || 0);
//                 const perSecondSalary = Number(perDaySalary) / (Number(shiftHours) * 3600);

//                 if (isHoliday) otSecondsHoliday += extraSeconds;
//                 else otSecondsWeekend += extraSeconds;

//                 if (overtimePolicy.payFactorType === ENUMS.payFactorType.MULTIPLIER) {
//                     const multiplier = isHoliday
//                         ? (overtimePolicy.holidayMultiplier ?? 1.5)
//                         : (overtimePolicy.weekendMultiplier ?? 1);
//                     totalOvertimeAmount += extraSeconds * perSecondSalary * multiplier;
//                 } else if (overtimePolicy.payFactorType === ENUMS.payFactorType.FIXED_TOTAL) {
//                     const perSecondFixed = (overtimePolicy.fixedTotal || 0) / 3600;
//                     totalOvertimeAmount += extraSeconds * perSecondFixed;
//                 }
//             }
//             continue;
//         }

//         const shiftSeconds = (shiftHours || 8) * 3600;

//         if (attendanceForDay && attendanceForDay.islateIn && penalisationPolicy?.enableLatePolicy) {
//             totalLateCount++;
//         }

//         if (attendanceForDay && attendanceForDay.isEarlyOut) {
//             totalEarlyOutCount++; // Count for penalty calculation

//             const earlyOutSeconds = Number(attendanceForDay.EarlyOutDuration || 0);
//             const graceSeconds = penalisationPolicy?.enableEarlyOutPolicy
//                 ? (penalisationPolicy.earlyOutGraceMinutes || 0) * 60
//                 : (paySchedule.earlyOutGraceMinutes || 0) * 60;

//             let deductionSeconds = 0;

//             // PaySchedule-based time deduction
//             if (paySchedule.payForEarlyOutWithinGrace) {
//                 if (earlyOutSeconds > graceSeconds) {
//                     deductionSeconds = earlyOutSeconds - graceSeconds;
//                 }
//             } else {
//                 deductionSeconds = earlyOutSeconds;
//             }

//             const timeBasedDeductionDays = Math.min(deductionSeconds / (shiftSeconds || 1), 1);
//             earlyOutTimeDeductionDays += timeBasedDeductionDays;

//             // Present days calculation
//             if (timeBasedDeductionDays >= 0.5) {
//                 presentDays += 0.5;
//                 absentDays += 0.5;
//             } else {
//                 presentDays += 1;
//             }

//             console.log(`Early out time deduction: ${timeBasedDeductionDays.toFixed(2)} days (${earlyOutSeconds}s out of ${shiftSeconds}s)`);

//         } else {
//             // Normal attendance/leave calculation
//             if (leaveFraction === 1) {
//                 if (isPaidLeave) paidLeaveDays++;
//                 else if (isUnpaidLeave) unpaidLeaveDays++;
//                 else absentDays++;
//             } else if (leaveFraction === 0.5) {
//                 if (attendanceForDay) presentDays += 0.5;
//                 else absentDays += 0.5;

//                 if (isPaidLeave) paidLeaveDays += 0.5;
//                 else if (isUnpaidLeave) unpaidLeaveDays += 0.5;
//             } else {
//                 if (attendanceForDay) presentDays++;
//                 else absentDays++;
//             }
//         }

//         // OVERTIME CALCULATION (working days)
//         if (attendanceForDay && attendanceForDay.ExtraTime > 0 && paySchedule.payForExtraTime && overtimePolicy) {
//             console.log("under overtime calculation for working day");
//             const extraSeconds = Number(attendanceForDay.ExtraTime || 0);
//             const perSecondSalary = Number(perDaySalary) / (Number(shiftHours) * 3600);
//             otSecondsWorking += extraSeconds;

//             if (overtimePolicy.payFactorType === ENUMS.payFactorType.MULTIPLIER) {
//                 const multiplier = overtimePolicy.workingMultiplier ?? 0.5;
//                 totalOvertimeAmount += extraSeconds * perSecondSalary * multiplier;
//             } else if (overtimePolicy.payFactorType === ENUMS.payFactorType.FIXED_TOTAL) {
//                 const perSecondFixed = (overtimePolicy.fixedTotal || 0) / 3600;
//                 totalOvertimeAmount += extraSeconds * perSecondFixed;
//             }
//         }
//     }

//     //  POLICY-BASED PENALTY CALCULATION
//     if (penalisationPolicy?.enableSalaryDeduction) {

//         // Late penalty
//         if (penalisationPolicy.enableLatePolicy) {
//             const lateAllowed = penalisationPolicy.lateAllowedPerMonth || 3;
//             const lateToHalfDay = penalisationPolicy.lateToHalfDay || 2;
//             const penalizableLates = Math.max(0, totalLateCount - lateAllowed);

//             if (penalizableLates > 0 && lateToHalfDay > 0) {
//                 const lateHalfDays = Math.floor(penalizableLates / lateToHalfDay) * 0.5;
//                 penaltyDeductionDays += lateHalfDays;
//                 console.log(`Late penalties: ${penalizableLates} lates (out of ${totalLateCount} total) â†’ ${lateHalfDays} half-days deducted`);
//             }
//         }

//         // Early out penalty
//         if (penalisationPolicy.enableEarlyOutPolicy) {
//             const earlyOutToHalfDay = penalisationPolicy.earlyOutToHalfDay || 2;

//             if (totalEarlyOutCount > 0 && earlyOutToHalfDay > 0) {
//                 const earlyOutHalfDays = Math.floor(totalEarlyOutCount / earlyOutToHalfDay) * 0.5;
//                 penaltyDeductionDays += earlyOutHalfDays;
//                 console.log(`Early out penalties: ${totalEarlyOutCount} early outs â†’ ${earlyOutHalfDays} half-days deducted`);
//             }
//         }
//     }

//     console.log(" DEDUCTION SUMMARY");
//     console.log("Early out time deduction:", earlyOutTimeDeductionDays.toFixed(2), "days (PaySchedule-based)");
//     console.log("Policy penalty deduction:", penaltyDeductionDays.toFixed(2), "days (PenalisationPolicy-based)");
//     console.log("Missing clock out amount:", missingClockOutPenaltyAmount, "rupees");
//     console.log("Total overtime amount:", totalOvertimeAmount);

//     const payableDays = presentDays + paidLeaveDays
//         + (paySchedule.payForWeekends ? countWeekends : 0)
//         + (paySchedule.payForHolidays ? countHolidays : 0);


//     const totalUnpaidDays = earlyOutTimeDeductionDays + penaltyDeductionDays;
//     const unpaidDeduction = (perDaySalary * totalUnpaidDays) + missingClockOutPenaltyAmount;

//     const grossEarnings = (perDaySalary * payableDays) + totalOvertimeAmount - unpaidDeduction;

//     const basic = grossSalary * 0.5;
//     const HRA = basic * 0.4;
//     const DA = basic * 0.1;
//     const otherAllowances = grossSalary - (basic + HRA + DA);

//     const earnings = {
//         basic,
//         HRA,
//         DA,
//         otherAllowances,
//         grossEarnings
//     };

//     const proratedBasic = (basic / totalWorkingDays) * payableDays;
//     const proratedDA = (DA / totalWorkingDays) * payableDays;

//     const pf = (proratedBasic + proratedDA) * 0.12;
//     const esi = grossEarnings <= 21000 ? grossEarnings * 0.0075 : 0;
//     const tax = grossEarnings > 25000 ? grossEarnings * 0.05 : 0;
//     const otherDeductions = 0;

//     const grossDeductions = pf + esi + tax;

//     const deductions = {
//         pf,
//         esi,
//         tax,
//         otherDeductions,
//         grossDeductions
//     };

//     const netSalary = Math.max(0, grossEarnings - grossDeductions);

//     return {
//         totalWorkingDays,
//         countWeekends,
//         countHolidays,
//         presentDays,
//         absentDays,
//         paidLeaveDays,
//         unpaidLeaveDays,
//         earlyOutTimeDeductionDays: Number(earlyOutTimeDeductionDays.toFixed(2)),

//         totalLateCount,
//         totalEarlyOutCount,
//         totalMissingClockOutCount,
//         penaltyDeductionDays: Number(penaltyDeductionDays.toFixed(2)),
//         missingClockOutPenaltyAmount: Number(missingClockOutPenaltyAmount.toFixed(2)),

//         perDaySalary: Number(perDaySalary.toFixed(2)),
//         payableDays: Number(payableDays.toFixed(2)),
//         totalUnpaidDays: Number(totalUnpaidDays.toFixed(2)),
//         unpaidDeduction: Number(unpaidDeduction.toFixed(2)),
//         totalOvertimeSeconds: otSecondsWorking + otSecondsWeekend + otSecondsHoliday,
//         earnings,
//         deductions,
//         totalOvertimeAmount: Number(totalOvertimeAmount.toFixed(2)),
//         netSalary: Number(netSalary.toFixed(2))
//     };
// };

// export default SalaryCalculationfunction;







//right one
// import User from "../models/auth.js";
// import Shift from "../models/Shift.js";
// import Attendance from "../models/Attendance.js";
// import Holiday from "../models/Holiday.js";
// import LeaveApplication from "../models/leaveApplication.js";
// import PaySchedule from "../models/paySchedule.js";
// import OvertimePolicy from "../models/overTimePolicy.js";
// import { getUTCRangeForISTDate, sameDay } from "../utils/time.js";
// import { ENUMS } from "./constants.js";

// const SalaryCalculationfunction = async (userId, startDate, endDate, grossSalary) => {
//     if (!userId || !startDate || !endDate) throw new Error("userId, startDate and endDate are required");

//     const user = await User.findById(userId);
//     if (!user) throw new Error("User not found");

//     const shift = await Shift.findOne({ assignUsers: userId });
//     if (!shift) throw new Error("User not assigned to any shift");

//     const holidays = await Holiday.find({
//         assignUsers: userId,
//         $or: [{ startDate: { $lte: endDate }, endDate: { $gte: startDate } }],
//     });

//     const leaveApplication = await LeaveApplication.find({
//         userId,
//         status: ENUMS.statusType.APPROVED,
//         $or: [{ startDate: { $lte: endDate }, endDate: { $gte: startDate } }],
//     }).populate("leavePolicyId");

//     const attendance = await Attendance.find({
//         userId,
//         date: { $gte: startDate, $lte: endDate },
//         clockIn: { $ne: null },
//     });

//     const paySchedule = await PaySchedule.findOne({ locationId: user.locationId });
//     if (!paySchedule) throw new Error("PaySchedule not found for user's location");

//     let overtimePolicy = null;
//     if (user.assignedOvertimePolicy) {
//         overtimePolicy = await OvertimePolicy.findById(user.assignedOvertimePolicy).lean();
//     }

//     const startIST = new Date(new Date(startDate).getTime() + 5.5 * 60 * 60 * 1000);
//     const endIST = new Date(endDate.getTime());

//     const dayInfos = [];
//     let totalWorkingDays = 0, countWeekends = 0, countHolidays = 0;

//     for (let cur = startIST.getTime(); cur <= endIST.getTime(); cur += 24 * 60 * 60 * 1000) {
//         const curDate = new Date(cur);
//         console.log(curDate)
//         const y = curDate.getUTCFullYear();
//         const m = curDate.getUTCMonth() + 1;
//         const d = curDate.getUTCDate();

//         const { startUTC, endUTC } = getUTCRangeForISTDate(y, m, d);
//         const dayOfWeek = new Date(Date.UTC(y, m - 1, d)).getUTCDay();
//         console.log(dayOfWeek)
//         const shiftDay = shift.days.get(String(dayOfWeek));

//         const isWeekend = shiftDay && shiftDay.dayStatus === ENUMS.DAY_STATUS.WEEKEND;
//         console.log("isweekend", isWeekend)
//         const isHoliday = holidays.some(h => startUTC <= h.endDate && endUTC >= h.startDate);
//         console.log("isHoliday", isHoliday)
//         const shiftHours = (shiftDay?.dayStatus === ENUMS.DAY_STATUS.FIRSTHALF || shiftDay?.dayStatus === ENUMS.DAY_STATUS.SECONDHALF)
//             ? (shift.halfDayHrs || 5)
//             : (shift.fullDayHrs || 8);

//         const attendanceForDay = attendance.find(a => a.date >= startUTC && a.date <= endUTC) || null;
//         console.log("attendaceFor" , attendanceForDay);

//         if (isWeekend) {
//             countWeekends++;
//             continue;
//         }
//         if (isHoliday) {
//             countHolidays++
//             continue
//         };
//         if (!isWeekend && !isHoliday) totalWorkingDays++;

//         dayInfos.push({ startUTC, endUTC, isWeekend, isHoliday, shiftHours, shiftDay, attendanceForDay ,totalWorkingDays });
//     }
//     // console.log(dayInfos)

//     if (totalWorkingDays === 0) totalWorkingDays = 1;

//     const perDaySalary = grossSalary / totalWorkingDays;
//     console.log("perdayDalary" , perDaySalary);

//     let presentDays = 0, absentDays = 0, paidLeaveDays = 0, unpaidLeaveDays = 0, earlyOutDeductionDays = 0;
//     let otSecondsWorking = 0, otSecondsWeekend = 0, otSecondsHoliday = 0;
//     let totalOvertimeAmount = 0;

//     for (const dayInfo of dayInfos) {
//         const { startUTC, shiftHours, isWeekend, isHoliday, attendanceForDay } = dayInfo;

//         let leaveFraction = 0, isPaidLeave = false, isUnpaidLeave = false;

//         for (let lp of leaveApplication) {
//             // console.log("lp" , lp)
//             const policy = lp.leavePolicyId;
//             const leaveDay = lp.leaveDays.find(ld => sameDay(ld.date, startUTC));
//             if (leaveDay) {
//                 leaveFraction = leaveDay.leaveType === ENUMS.leaveType.FULL ? 1 : 0.5;
//                 if (policy.policyType === ENUMS.leavePolicyType.paidLeave) isPaidLeave = true;
//                 else if (policy.policyType === ENUMS.leavePolicyType.unpaidLeave) isUnpaidLeave = true;
//                 break;
//             }
//         }

//         if (isWeekend || isHoliday) {
//             if (attendanceForDay && attendanceForDay.ExtraTime > 0 && paySchedule.payForExtraTime && overtimePolicy) {
//                 console.log("under isweekend isholiday , and extratime")
//                 const extraSeconds = Number(attendanceForDay.ExtraTime || 0);
//                 const perSecondSalary = Number(perDaySalary) / (Number(shiftHours) * 3600);

//                 if (isHoliday) otSecondsHoliday += extraSeconds;
//                 else otSecondsWeekend += extraSeconds;

//                 if (overtimePolicy.payFactorType === ENUMS.payFactorType.MULTIPLIER) {
//                     const multiplier = isHoliday
//                         ? (overtimePolicy.holidayMultiplier ?? 1.5)
//                         : (overtimePolicy.weekendMultiplier ?? 1);
//                     totalOvertimeAmount += extraSeconds * perSecondSalary * multiplier;
//                 } else if (overtimePolicy.payFactorType === ENUMS.payFactorType.FIXED_TOTAL) {
//                     const perSecondFixed = (overtimePolicy.fixedTotal || 0) / 3600;
//                     totalOvertimeAmount += extraSeconds * perSecondFixed;
//                 }
//             }
//             continue;
//         }

//         const shiftSeconds = (shiftHours || 8) * 3600;

//         if (attendanceForDay && attendanceForDay.isEarlyOut) {
//             const earlyOutSeconds = Number(attendanceForDay.EarlyOutDuration || 0);
//             const graceSeconds = (paySchedule.earlyOutGraceMinutes || 0) * 60;
//             let deductionSeconds = 0;
//             console.log("ealyoutsec", earlyOutSeconds);
//             console.log("graceSec", graceSeconds);
//             if (paySchedule.payForEarlyOutWithinGrace) {
//                 console.log("payschedule payForEarlyOutWithinGrace true")
//                 if (earlyOutSeconds > graceSeconds) deductionSeconds = earlyOutSeconds - graceSeconds;
//             } else deductionSeconds = earlyOutSeconds;

//             const deductionDays = Math.min(deductionSeconds / (shiftSeconds || 1), 1);
//             if (deductionDays >= 0.5) {
//                 presentDays += 0.5;
//                 absentDays += 0.5;
//                 console.log("deduction days >= 0.5 ", presentDays)
//                 earlyOutDeductionDays += deductionDays; // deduct half day
//             } else {
//                 presentDays += 1;
//                 console.log("underealyrout presentdasys", presentDays)
//                 earlyOutDeductionDays += deductionDays;
//                 console.log("earlyoutdeductiondays", earlyOutDeductionDays)
//             }

//         } else {
//             if (leaveFraction === 1) {
//                 if (isPaidLeave) paidLeaveDays++;
//                 else if (isUnpaidLeave) unpaidLeaveDays++;
//                 else absentDays++;
//             } else if (leaveFraction === 0.5) {
//                 if (attendanceForDay) presentDays += 0.5;
//                 else absentDays += 0.5;

//                 if (isPaidLeave) paidLeaveDays += 0.5;
//                 else if (isUnpaidLeave) unpaidLeaveDays += 0.5;
//             } else {
//                 if (attendanceForDay) presentDays++;
//                 else absentDays++;
//             }
//         }


//         if (attendanceForDay && attendanceForDay.ExtraTime > 0 && paySchedule.payForExtraTime && overtimePolicy) {
//             console.log("under next ")
//             const extraSeconds = Number(attendanceForDay.ExtraTime || 0);
//             const perSecondSalary = Number(perDaySalary) / (Number(shiftHours) * 3600);
//             otSecondsWorking += extraSeconds;

//             if (overtimePolicy.payFactorType === ENUMS.payFactorType.MULTIPLIER) {
//                 const multiplier = overtimePolicy.workingMultiplier ?? 0.5;
//                 totalOvertimeAmount += extraSeconds * perSecondSalary * multiplier;
//             } else if (overtimePolicy.payFactorType === ENUMS.payFactorType.FIXED_TOTAL) {
//                 const perSecondFixed = (overtimePolicy.fixedTotal || 0) / 3600;
//                 totalOvertimeAmount += extraSeconds * perSecondFixed;
//             }
//         }
//     }
//     console.log("totalot" , totalOvertimeAmount)

//     const payableDays = presentDays + paidLeaveDays
//         + (paySchedule.payForWeekends ? countWeekends : 0)
//         + (paySchedule.payForHolidays ? countHolidays : 0);

//     const grossEarnings = perDaySalary * payableDays + totalOvertimeAmount;

//     const basic = grossSalary * 0.5;
//     const HRA = basic * 0.4;
//     const DA = basic * 0.1;
//     const otherAllowances = grossSalary - (basic + HRA + DA);

//     const earnings = {
//         basic,
//         HRA,
//         DA,
//         otherAllowances,
//         grossEarnings
//     }

//     const proratedBasic = (basic / totalWorkingDays) * payableDays;
//     const proratedDA = (DA / totalWorkingDays) * payableDays;

//     const pf = (proratedBasic + proratedDA) * 0.12;
//     const esi = grossEarnings <= 21000 ? grossEarnings * 0.0075 : 0;
//     const tax = grossEarnings > 25000 ? grossEarnings * 0.05 : 0;
//     const otherDeductions = 0;

//     const grossDeductions = pf + esi + tax;

//     const deductions = {
//         pf,
//         esi,
//         tax,
//         otherDeductions,
//         grossDeductions
//     }

//     const totalUnpaidDays = unpaidLeaveDays + absentDays + earlyOutDeductionDays;
//     const unpaidDeduction = perDaySalary * totalUnpaidDays;

//     const netSalary = Math.max(0, grossEarnings - grossDeductions);

//     return {
//         totalWorkingDays,
//         countWeekends,
//         countHolidays,
//         presentDays,
//         absentDays,
//         paidLeaveDays,
//         unpaidLeaveDays,
//         earlyOutDeductionDays: Number(earlyOutDeductionDays.toFixed(2)),
//         totalUnpaidDays,
//         perDaySalary: Number(perDaySalary.toFixed(2)),
//         payableDays,
//         unpaidDeduction: Number(unpaidDeduction.toFixed(2)),
//         totalOvertimeSeconds: otSecondsWorking + otSecondsWeekend + otSecondsHoliday,
//         earnings,
//         deductions,
//         totalOvertimeAmount: Number(totalOvertimeAmount.toFixed(2)),
//         netSalary: netSalary.toFixed(2)
//     };
// };

// export default SalaryCalculationfunction;





// import User from "../models/auth.js";
// import Shift from "../models/Shift.js";
// import Attendance from "../models/Attendance.js";
// import Holiday from "../models/Holiday.js";
// import LeaveApplication from "../models/leaveApplication.js";
// import Salary from "../models/salary.js";
// import { istStartOfDayToUTC, istEndOfDayToUTC } from "../utils/time.js";
// import { ENUMS } from "./constants.js";

// const SalaryCalculationfunction = async (userId, startDate, endDate) => {
//     if (!userId || !startDate || !endDate)
//         throw new Error("userId, startDate and endDate are required");

//     const user = await User.findById(userId);
//     if (!user) throw new Error("User not found for this Id");

//     const shift = await Shift.findOne({ assignUsers: userId });
//     if (!shift) throw new Error("User not assigned to any shift");

//     const start = istStartOfDayToUTC(startDate);
//     console.log(startDate)
//     const end = istEndOfDayToUTC(endDate);
//     const salarySlip = await Salary.find({
//         userId,
//         startDate: { $lte: end },
//         endDate: { $gte: start },
//     }).lean();

//     if (!salarySlip.length) throw new Error("No salary record found for range");

//     const allSalaryPeriods = [];

//     for (const salary of salarySlip ) {
//         const periodStart = salary.startDate > start ? salary.startDate : start;
//         const periodEnd = salary.endDate < end ? salary.endDate : end;

//         console.log("periodStart", periodStart);
//         console.log("end", periodEnd)
//         const holidays = await Holiday.find({
//             assignUsers: userId,
//             $or: [{ startDate: { $lte: periodEnd }, endDate: { $gte: periodStart } }],
//         });
//         console.log(holidays.length)
//         const leaveApplication = await LeaveApplication.find({
//             userId,
//             status: ENUMS.statusType.APPROVED,
//             $or: [{ startDate: { $lte: periodEnd }, endDate: { $gte: periodStart } }],
//         }).populate("leavePolicyId");
//         console.log(leaveApplication.length)

//         const attendance = await Attendance.find({
//             userId,
//             date: { $gte: periodStart, $lte: periodEnd },
//             clockIn: { $ne: null },
//         });

//         console.log(attendance.length)

//         let totalWorkingDays = 0,
//             presentDays = 0,
//             absentDays = 0,
//             paidLeaveDays = 0,
//             unpaidLeaveDays = 0,
//             countWeekend = 0,
//             countHolidays = 0;

//         const startUtc = periodStart.getTime() + 5.5 * 60 * 60 * 1000;
//         console.log(startUtc)
//         const endUtc = periodEnd.getTime();
//         console.log(endUtc)

//         for (
//             let cur = startUtc;
//             cur <= endUtc;
//             cur += 24 * 60 * 60 * 1000
//         ) {
//             console.log("cur", cur)
//             const curUTC = new Date(new Date(cur) - 5.5 * 60 * 60 * 1000);
//             console.log("curutc", curUTC)

//             const dayOfWeek = curUTC.getDay();
//             console.log(dayOfWeek)
//             const shiftDay = shift?.days.get(String(dayOfWeek));
//             console.log(shiftDay)


//             if (shiftDay && shiftDay.dayStatus === ENUMS.DAY_STATUS.WEEKEND) {
//                 countWeekend++;
//                 continue;
//             }

//             const isHoliday = holidays.some(
//                 (h) => h.startDate <= curUTC && h.endDate >= curUTC
//             );
//             if (isHoliday) {
//                 countHolidays++;
//                 continue;
//             }

//             totalWorkingDays++;

//             let leaveFraction = 0,
//                 isPaidLeave = false,
//                 isUnpaidLeave = false;

//             for (const lp of leaveApplication) {
//                 const leaveFound = lp.leaveDays.find(d => d.date <= curUTC && d.date >= curUTC);
//                 if (leaveFound) {
//                     leaveFraction =
//                         leaveFound.leaveType === ENUMS.leaveType.FULL ? 1 : 0.5;
//                     const policy = lp.leavePolicyId;
//                     if (policy.policyType === ENUMS.leavePolicyType.paidLeave)
//                         isPaidLeave = true;
//                     else if (policy.policyType === ENUMS.leavePolicyType.unpaidLeave)
//                         isUnpaidLeave = true;
//                     break;
//                 }
//             }

//             const hasAttendance = attendance.some(d => d.date <= curUTC && d.date >= curUTC);

//             if (leaveFraction === 1) {
//                 if (isPaidLeave) paidLeaveDays += 1;
//                 else if (isUnpaidLeave) unpaidLeaveDays += 1;
//                 else absentDays += 1;
//             } else if (leaveFraction === 0.5) {
//                 if (hasAttendance) presentDays += 0.5;
//                 else absentDays += 0.5;
//                 if (isPaidLeave) paidLeaveDays += 0.5;
//                 else if (isUnpaidLeave) unpaidLeaveDays += 0.5;
//             } else {
//                 if (hasAttendance) presentDays += 1;
//                 else absentDays += 1;
//             }
//         }

//         const perDaySalary = salary.salary / (totalWorkingDays || 1);
//         console.log(perDaySalary)
//         const totalUnpaidDays = unpaidLeaveDays + absentDays;
//         const payableDays = presentDays + paidLeaveDays;
//         const payableSalary = perDaySalary * payableDays;
//         const unpaidDeduction = perDaySalary * totalUnpaidDays;
//         const netSalary = Math.max(0,  salary.salary  - unpaidDeduction);

//         allSalaryPeriods.push({
//             salaryId: salary._id,
//             startDate: periodStart,
//             endDate: periodEnd,
//             frequencyType: salary.frequencyType,
//             salary: salary.salary,
//             perDaySalary: perDaySalary.toFixed(2),
//             totalWorkingDays,
//             presentDays,
//             absentDays,
//             paidLeaveDays,
//             unpaidLeaveDays,
//             holidays: countHolidays,
//             weekends: countWeekend,
//             payableDays,
//             payableSalary,
//             totalUnpaidDays,
//             unpaidDeduction: unpaidDeduction.toFixed(2),
//             totalDeductions: unpaidDeduction.toFixed(2),
//             netSalary: netSalary.toFixed(2),
//         });
//     }

//     return allSalaryPeriods;
// };

// export default SalaryCalculationfunction;

