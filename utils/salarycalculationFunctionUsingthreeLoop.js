import User from "../models/auth.js";
import Shift from "../models/Shift.js";
import Attendance from "../models/Attendance.js";
import Holiday from "../models/Holiday.js";
import LeaveApplication from "../models/leaveApplication.js";
import PaySchedule from "../models/paySchedule.js";
import OvertimePolicy from "../models/overTimePolicy.js";
import PenalisationPolicy from "../models/PenalisationPolicy.js";
import { getUTCRangeForISTDate, sameDay } from "../utils/time.js";
import { ENUMS } from "./constants.js";

const SalaryCalculationfunction = async (userId, startDate, endDate, grossSalary) => {
    if (!userId || !startDate || !endDate) throw new Error("userId, startDate and endDate are required");

    const user = await User.findById(userId);
    if (!user) throw new Error("User not found");

    const shift = await Shift.findOne({ assignUsers: userId });
    if (!shift) throw new Error("User not assigned to any shift");

    const holidays = await Holiday.find({
        assignUsers: userId,
        $or: [{ startDate: { $lte: endDate }, endDate: { $gte: startDate } }],
    });

    const leaveApplication = await LeaveApplication.find({
        userId,
        status: ENUMS.statusType.APPROVED,
        $or: [{ startDate: { $lte: endDate }, endDate: { $gte: startDate } }],
    }).populate("leavePolicyId");

    const existingAttendanceRecords = await Attendance.find({
        userId,
        date: { $gte: startDate, $lte: endDate }
    }).lean();

    const existingAttendanceMap = new Map();
    existingAttendanceRecords.forEach(att => {
        const key = att.date.toISOString().split('T')[0];
        existingAttendanceMap.set(key, att);
    });

    console.log("\n AUTO-GENERATING ATTENDANCE RECORDS");
    const startIST = new Date(new Date(startDate).getTime() + 5.5 * 60 * 60 * 1000);
    const endIST = new Date(endDate.getTime());

    const attendanceToCreate = [];
    for (let cur = startIST.getTime(); cur <= endIST.getTime(); cur += 24 * 60 * 60 * 1000) {
        const curDate = new Date(cur);
        const y = curDate.getUTCFullYear();
        const m = curDate.getUTCMonth() + 1;
        const d = curDate.getUTCDate();

        const { startUTC, endUTC } = getUTCRangeForISTDate(y, m, d);
        const dateKey = startUTC.toISOString().split('T')[0];

        //  Check from Map instead of DB query
        if (existingAttendanceMap.has(dateKey)) {
            console.log(`Attendance exists for ${dateKey} - Skipping`);
            continue;
        }

        let dayStatus = ENUMS.DAY_STATUS.WORKING;

        const isHoliday = holidays.some(h => startUTC <= h.endDate && endUTC >= h.startDate);
        
        if (isHoliday) {
            dayStatus = ENUMS.DAY_STATUS.HOLIDAY;
        } else {
            const dayOfWeek = new Date(Date.UTC(y, m - 1, d)).getUTCDay();
            const shiftDay = shift.days.get(String(dayOfWeek));
            
            if (shiftDay && shiftDay.dayStatus) {
                dayStatus = shiftDay.dayStatus;
            }
        }

        attendanceToCreate.push({
            userId,
            shiftId: shift._id,
            date: startUTC,
            dayStatus,
            clockIn: null,
            clockOut: null,
            totalWorkingTime: 0,
            ExtraTime: 0,
            islateIn: false,
            isEarlyOut: false,
            EarlyOutDuration: 0,
            autoGenerated: true
        });
    }

    if (attendanceToCreate.length > 0) {
        await Attendance.insertMany(attendanceToCreate);
        console.log(` Created ${attendanceToCreate.length} missing attendance records`);
    }

    // Fetch all attendance records after auto-generation
    const attendance = await Attendance.find({
        userId,
        date: { $gte: startDate, $lte: endDate }
    });

    console.log(`\nTotal attendance records: ${attendance.length}`);

    const paySchedule = await PaySchedule.findOne({ locationId: user.locationId });
    if (!paySchedule) throw new Error("PaySchedule not found for user's location");

    const penalisationPolicy = await PenalisationPolicy.findOne({ locationId: user.locationId });

    let overtimePolicy = null;
    if (user.assignedOvertimePolicy) {
        overtimePolicy = await OvertimePolicy.findById(user.assignedOvertimePolicy).lean();
    }

    const dayInfos = [];
    let totalWorkingDays = 0, countWeekends = 0, countHolidays = 0;

    for (let cur = startIST.getTime(); cur <= endIST.getTime(); cur += 24 * 60 * 60 * 1000) {
        const curDate = new Date(cur);
        const y = curDate.getUTCFullYear();
        const m = curDate.getUTCMonth() + 1;
        const d = curDate.getUTCDate();

        const { startUTC, endUTC } = getUTCRangeForISTDate(y, m, d);

        const dayOfWeek = new Date(Date.UTC(y, m - 1, d)).getUTCDay();
        const shiftDay = shift.days.get(String(dayOfWeek));
        const shiftHours = (shiftDay?.dayStatus === ENUMS.DAY_STATUS.FIRSTHALF || shiftDay?.dayStatus === ENUMS.DAY_STATUS.SECONDHALF)
            ? (shift.halfDayHrs || 5)
            : (shift.fullDayHrs || 8);

        const attendanceForDay = attendance.find(a => a.date >= startUTC && a.date <= endUTC) || null;

        const isWeekend = attendanceForDay?.dayStatus === ENUMS.DAY_STATUS.WEEKEND;
        const isHoliday = attendanceForDay?.dayStatus === ENUMS.DAY_STATUS.HOLIDAY;

        if (isWeekend) {
            countWeekends++;
            dayInfos.push({ startUTC, endUTC, isWeekend, isHoliday, shiftHours, shiftDay, attendanceForDay, type: 'WEEKEND' });
            continue;
        }
        if (isHoliday) {
            countHolidays++;
            dayInfos.push({ startUTC, endUTC, isWeekend, isHoliday, shiftHours, shiftDay, attendanceForDay, type: 'HOLIDAY' });
            continue;
        }

        totalWorkingDays++;
        dayInfos.push({ startUTC, endUTC, isWeekend, isHoliday, shiftHours, shiftDay, attendanceForDay, type: 'WORKING' });
    }

    if (totalWorkingDays === 0) totalWorkingDays = 1;

    const perDaySalary = grossSalary / totalWorkingDays;
    console.log("Per day salary:", perDaySalary);

    let presentDays = 0, absentDays = 0, paidLeaveDays = 0, unpaidLeaveDays = 0;
    let otSecondsWorking = 0, otSecondsWeekend = 0, otSecondsHoliday = 0;
    let totalOvertimeAmount = 0;

    let totalLateCount = 0;
    let totalEarlyOutCount = 0;
    let totalMissingClockOutCount = 0;

    let earlyOutTimeDeductionDays = 0;
    let penaltyDeductionDays = 0;
    let missingClockOutPenaltyAmount = 0;
    let instantLateInPenaltyAmount = 0;
    let instantEarlyOutPenaltyAmount = 0;

    const penaltyRule = penalisationPolicy?.penaltyRuleForLateWithEarlyOut || ENUMS.penaltyRuleType.BOTH;

    // PROCESS EACH DAY
    for (const dayInfo of dayInfos) {
        const { startUTC, shiftHours, isWeekend, isHoliday, attendanceForDay, type } = dayInfo;
        const shiftSeconds = (shiftHours || 8) * 3600;

        console.log(`\n=== Processing ${startUTC.toISOString().split('T')[0]} (${type}) ===`);

        // WEEKEND/HOLIDAY OVERTIME
        if (isWeekend || isHoliday) {
            if (attendanceForDay && attendanceForDay.clockIn && attendanceForDay.ExtraTime > 0 && paySchedule.payForExtraTime && overtimePolicy) {
                console.log(`${type} overtime detected`);
                const extraSeconds = Number(attendanceForDay.ExtraTime || 0);
                const perSecondSalary = Number(perDaySalary) / (Number(shiftHours) * 3600);

                if (isHoliday) otSecondsHoliday += extraSeconds;
                else otSecondsWeekend += extraSeconds;

                if (overtimePolicy.payFactorType === ENUMS.payFactorType.MULTIPLIER) {
                    const multiplier = isHoliday
                        ? (overtimePolicy.holidayMultiplier ?? 1.5)
                        : (overtimePolicy.weekendMultiplier ?? 1);
                    totalOvertimeAmount += extraSeconds * perSecondSalary * multiplier;
                    console.log(`OT: ${extraSeconds}s * ${perSecondSalary.toFixed(2)} * ${multiplier} = ${(extraSeconds * perSecondSalary * multiplier).toFixed(2)}`);
                } else if (overtimePolicy.payFactorType === ENUMS.payFactorType.FIXED_TOTAL) {
                    const perSecondFixed = (overtimePolicy.fixedTotal || 0) / 3600;
                    totalOvertimeAmount += extraSeconds * perSecondFixed;
                    console.log(`OT: ${extraSeconds}s * ${perSecondFixed.toFixed(2)} = ${(extraSeconds * perSecondFixed).toFixed(2)}`);
                }
            }
            continue;
        }

        // Check for leave FIRST 
        let leaveFraction = 0, isPaidLeave = false, isUnpaidLeave = false;
        for (let lp of leaveApplication) {
            const policy = lp.leavePolicyId;
            const leaveDay = lp.leaveDays.find(ld => sameDay(ld.date, startUTC));
            if (leaveDay) {
                leaveFraction = leaveDay.leaveType === ENUMS.leaveType.FULL ? 1 : 0.5;
                if (policy.policyType === ENUMS.leavePolicyType.paidLeave) isPaidLeave = true;
                else if (policy.policyType === ENUMS.leavePolicyType.unpaidLeave) isUnpaidLeave = true;
                console.log(` Leave: ${leaveFraction} day, ${isPaidLeave ? 'PAID' : isUnpaidLeave ? 'UNPAID' : 'ABSENT'}`);
                break;
            }
        }

        if (attendanceForDay && attendanceForDay.clockIn && !attendanceForDay.clockOut) {
            totalMissingClockOutCount++;
            console.log(" Missing clock out detected");

            const availableDay = 1 - leaveFraction;
            console.log(` Available day for penalty: ${availableDay} (after ${leaveFraction} leave)`);

            if (!penalisationPolicy?.enableMissingClockOutPenalty) {
                absentDays += availableDay;
                console.log(` No policy - ${availableDay} day absent`);
                
                if (leaveFraction > 0) {
                    if (isPaidLeave) paidLeaveDays += leaveFraction;
                    else if (isUnpaidLeave) unpaidLeaveDays += leaveFraction;
                    console.log(` ${leaveFraction} day ${isPaidLeave ? 'PAID' : 'UNPAID'} leave added`);
                }
                continue;
            }

            if (penalisationPolicy.missingClockOutPenaltyType === ENUMS.missingClockOutPenaltyType.AMOUNT) {
                missingClockOutPenaltyAmount += (penalisationPolicy.missingClockOutPenaltyAmount || 0);
                presentDays += availableDay;  
                console.log(` Amount penalty: ${penalisationPolicy.missingClockOutPenaltyAmount} - ${availableDay} day present`);
            } else if (penalisationPolicy.missingClockOutPenaltyType === ENUMS.missingClockOutPenaltyType.LEAVE) {
                const dayType = penalisationPolicy.missingClockOutDayType || ENUMS.leaveType.FULL;
                const leaveType = penalisationPolicy.missingClockOutLeaveType || ENUMS.leavePolicyType.unpaidLeave;
                const isPenaltyPaid = (leaveType === ENUMS.leavePolicyType.paidLeave);

                if (dayType === ENUMS.leaveType.FULL) {
                    if (isPenaltyPaid) paidLeaveDays += availableDay;
                    else unpaidLeaveDays += availableDay;
                    console.log(` Full day ${isPenaltyPaid ? 'PAID' : 'UNPAID'} leave penalty: ${availableDay} day`);
                } else {
                    const penaltyAmount = Math.min(0.5, availableDay);
                    const remaining = availableDay - penaltyAmount;
                    
                    presentDays += remaining;
                    if (isPenaltyPaid) paidLeaveDays += penaltyAmount;
                    else unpaidLeaveDays += penaltyAmount;
                    console.log(` Half day ${isPenaltyPaid ? 'PAID' : 'UNPAID'} leave penalty: ${penaltyAmount}, ${remaining} present`);
                }
            }

            if (leaveFraction > 0) {
                if (isPaidLeave) paidLeaveDays += leaveFraction;
                else if (isUnpaidLeave) unpaidLeaveDays += leaveFraction;
                console.log(` Original ${leaveFraction} day ${isPaidLeave ? 'PAID' : 'UNPAID'} leave added`);
            }
            continue;
        }

        // Full day leave
        if (leaveFraction === 1) {
            if (isPaidLeave) paidLeaveDays += 1;
            else if (isUnpaidLeave) unpaidLeaveDays += 1;
            else absentDays += 1;
            console.log(" Full day leave - no attendance");
            continue;
        }

        // Half day leave with no attendance
        if (leaveFraction === 0.5 && (!attendanceForDay || !attendanceForDay.clockIn)) {
            if (isPaidLeave) paidLeaveDays += 0.5;
            else if (isUnpaidLeave) unpaidLeaveDays += 0.5;
            absentDays += 0.5;
            console.log(" 0.5 leave + 0.5 absent");
            continue;
        }

        // No attendance and no leave
        if ((!attendanceForDay || !attendanceForDay.clockIn) && leaveFraction === 0) {
            absentDays += 1;
            console.log(" No attendance, no leave - 1 day absent");
            continue;
        }

        // Add half day leave counts if applicable
        if (leaveFraction === 0.5) {
            if (isPaidLeave) paidLeaveDays += 0.5;
            else if (isUnpaidLeave) unpaidLeaveDays += 0.5;
            console.log(" Half day leave recorded, processing remaining 0.5 day attendance...");
        }

        // Available attendance for this day 
        const availableAttendance = leaveFraction === 0.5 ? 0.5 : 1;
        console.log(` Available attendance to process: ${availableAttendance} day`);

        const hasLateIn = attendanceForDay.islateIn && penalisationPolicy?.enableLatePolicy;
        const hasEarlyOut = attendanceForDay.isEarlyOut && penalisationPolicy?.enableEarlyOutPolicy;

        let applyLateInPenalty = false;
        let applyEarlyOutPenalty = false;

        if (hasLateIn && hasEarlyOut) {
            console.log(` Both Late & Early - Rule: ${penaltyRule}`);
            switch (penaltyRule) {
                case 1:
                case 2:
                    applyLateInPenalty = true;
                    applyEarlyOutPenalty = false;
                    console.log(" Applying ONLY Late In penalty");
                    break;
                case 3:
                    applyLateInPenalty = false;
                    applyEarlyOutPenalty = true;
                    console.log(" Applying ONLY Early Out penalty");
                    break;
                case 4:
                default:
                    applyLateInPenalty = true;
                    applyEarlyOutPenalty = true;
                    console.log("- Applying BOTH penalties");
                    break;
            }
        } else {
            applyLateInPenalty = hasLateIn;
            applyEarlyOutPenalty = hasEarlyOut;
            if (hasLateIn) console.log(" Late In detected");
            if (hasEarlyOut) console.log(" Early Out detected");
        }

        let remainingAttendance = availableAttendance;

        if (applyLateInPenalty) {
            console.log("- Processing Late In penalty...");

            if (penalisationPolicy.applyInstantPenaltyForLateIn) {
                console.log("  - Instant penalty enabled");
                if (penalisationPolicy.instantLateInPenaltyType === ENUMS.instantPenaltyType.AMOUNT) {
                    instantLateInPenaltyAmount += (penalisationPolicy.instantLateInPenaltyAmount || 0);
                    console.log(`  - Instant AMOUNT: ${penalisationPolicy.instantLateInPenaltyAmount} (no attendance reduction)`);
                } else if (penalisationPolicy.instantLateInPenaltyType === ENUMS.instantPenaltyType.LEAVE) {
                    const dayType = penalisationPolicy.instantLateInDayType || ENUMS.leaveType.SECONDHALF;
                    const leaveType = penalisationPolicy.instantLateInLeaveType || ENUMS.leavePolicyType.unpaidLeave;
                    const isPaid = (leaveType === ENUMS.leavePolicyType.paidLeave);

                    if (dayType === ENUMS.leaveType.FULL) {
                        if (isPaid) paidLeaveDays += remainingAttendance;
                        else unpaidLeaveDays += remainingAttendance;
                        console.log(`  - Instant FULL ${isPaid ? 'PAID' : 'UNPAID'}: ${remainingAttendance} day`);
                        remainingAttendance = 0;
                    } else {
                        const halfDayPenalty = Math.min(0.5, remainingAttendance);
                        if (isPaid) paidLeaveDays += halfDayPenalty;
                        else unpaidLeaveDays += halfDayPenalty;
                        remainingAttendance -= halfDayPenalty;
                        console.log(`  - Instant HALF ${isPaid ? 'PAID' : 'UNPAID'}: ${halfDayPenalty} day (remaining: ${remainingAttendance})`);
                    }
                }
            } else {
                totalLateCount++;
                console.log(`  - Counter-based: count = ${totalLateCount} (no immediate deduction)`);
            }
        }

        if (applyEarlyOutPenalty && remainingAttendance > 0) {
            console.log("- Processing Early Out penalty...");

            if (penalisationPolicy.applyInstantPenaltyForEarlyOut) {
                console.log("  - Instant penalty enabled");
                if (penalisationPolicy.instantEarlyOutPenaltyType === ENUMS.instantPenaltyType.AMOUNT) {
                    instantEarlyOutPenaltyAmount += (penalisationPolicy.instantEarlyOutPenaltyAmount || 0);
                    console.log(`  - Instant AMOUNT: ${penalisationPolicy.instantEarlyOutPenaltyAmount} (no attendance reduction)`);
                } else if (penalisationPolicy.instantEarlyOutPenaltyType === ENUMS.instantPenaltyType.LEAVE) {
                    const dayType = penalisationPolicy.instantEarlyOutDayType || ENUMS.leaveType.SECONDHALF;
                    const leaveType = penalisationPolicy.instantEarlyOutLeaveType || ENUMS.leavePolicyType.unpaidLeave;
                    const isPaid = (leaveType === ENUMS.leavePolicyType.paidLeave);

                    if (dayType === ENUMS.leaveType.FULL) {
                        if (isPaid) paidLeaveDays += remainingAttendance;
                        else unpaidLeaveDays += remainingAttendance;
                        console.log(`  - Instant FULL ${isPaid ? 'PAID' : 'UNPAID'}: ${remainingAttendance} day`);
                        remainingAttendance = 0;
                    } else {
                        const halfDayPenalty = Math.min(0.5, remainingAttendance);
                        if (isPaid) paidLeaveDays += halfDayPenalty;
                        else unpaidLeaveDays += halfDayPenalty;
                        remainingAttendance -= halfDayPenalty;
                        console.log(`  - Instant HALF ${isPaid ? 'PAID' : 'UNPAID'}: ${halfDayPenalty} day (remaining: ${remainingAttendance})`);
                    }
                }
            } else {
                totalEarlyOutCount++;

                const earlyOutSeconds = Number(attendanceForDay.EarlyOutDuration || 0);
                const graceSeconds = (penalisationPolicy.earlyOutGraceMinutes || 0) * 60;

                let deductionSeconds = paySchedule.payForEarlyOutWithinGrace
                    ? Math.max(0, earlyOutSeconds - graceSeconds)
                    : earlyOutSeconds;

                const timeBasedDeductionDays = Math.min(deductionSeconds / shiftSeconds, remainingAttendance);
                earlyOutTimeDeductionDays += timeBasedDeductionDays;

                console.log(`  - Counter-based: count = ${totalEarlyOutCount}, time deduction = ${timeBasedDeductionDays.toFixed(2)} days`);

                if (timeBasedDeductionDays >= 0.5) {
                    const absenceAmount = Math.min(0.5, remainingAttendance);
                    remainingAttendance -= absenceAmount;
                    absentDays += absenceAmount;
                    console.log(`  - Time deduction >= 0.5 - ${absenceAmount} day marked absent (remaining: ${remainingAttendance})`);
                }
            }
        }

        presentDays += remainingAttendance;
        console.log(` Final: ${remainingAttendance} day marked present`);

        if (attendanceForDay.ExtraTime > 0 && paySchedule.payForExtraTime && overtimePolicy) {
            console.log(" Overtime calculation...");
            const extraSeconds = Number(attendanceForDay.ExtraTime || 0);
            const perSecondSalary = Number(perDaySalary) / (Number(shiftHours) * 3600);
            otSecondsWorking += extraSeconds;

            if (overtimePolicy.payFactorType === ENUMS.payFactorType.MULTIPLIER) {
                const multiplier = overtimePolicy.workingMultiplier ?? 0.5;
                const otAmount = extraSeconds * perSecondSalary * multiplier;
                totalOvertimeAmount += otAmount;
                console.log(`  - OT: ${extraSeconds}s * ${perSecondSalary.toFixed(4)} * ${multiplier} = ${otAmount.toFixed(2)}`);
            } else if (overtimePolicy.payFactorType === ENUMS.payFactorType.FIXED_TOTAL) {
                const perSecondFixed = (overtimePolicy.fixedTotal || 0) / 3600;
                const otAmount = extraSeconds * perSecondFixed;
                totalOvertimeAmount += otAmount;
                console.log(`  - OT: ${extraSeconds}s * ${perSecondFixed.toFixed(2)} = ${otAmount.toFixed(2)}`);
            }
        }
    }

    console.log("\n\n=== COUNTER-BASED PENALTY PROCESSING ===");
    if (penalisationPolicy?.enableSalaryDeduction) {
        if (penalisationPolicy.enableLatePolicy && !penalisationPolicy.applyInstantPenaltyForLateIn) {
            const lateAllowed = penalisationPolicy.lateAllowedPerMonth || 3;
            const lateToHalfDay = penalisationPolicy.lateToHalfDay || 2;
            const penalizableLates = Math.max(0, totalLateCount - lateAllowed);

            if (penalizableLates > 0 && lateToHalfDay > 0) {
                const lateHalfDays = Math.floor(penalizableLates / lateToHalfDay) * 0.5;
                penaltyDeductionDays += lateHalfDays;
                console.log(`Late In: ${totalLateCount} total, ${lateAllowed} allowed - ${penalizableLates} penalizable - ${lateHalfDays} days deducted`);
            } else {
                console.log(`Late In: ${totalLateCount} total (within allowed limit of ${lateAllowed})`);
            }
        }

        if (penalisationPolicy.enableEarlyOutPolicy && !penalisationPolicy.applyInstantPenaltyForEarlyOut) {
            const earlyOutToHalfDay = penalisationPolicy.earlyOutToHalfDay || 2;

            if (totalEarlyOutCount > 0 && earlyOutToHalfDay > 0) {
                const earlyOutHalfDays = Math.floor(totalEarlyOutCount / earlyOutToHalfDay) * 0.5;
                penaltyDeductionDays += earlyOutHalfDays;
                console.log(`Early Out: ${totalEarlyOutCount} total - ${earlyOutHalfDays} days deducted`);
            } else {
                console.log(`Early Out: ${totalEarlyOutCount} total, no counter deduction`);
            }
        }
    }

    console.log("\n\n=== FINAL SALARY CALCULATION ===");

    const totalAccounted = presentDays + absentDays + paidLeaveDays + unpaidLeaveDays;
    
    console.log("\n ATTENDANCE SUMMARY:");
    console.log(`Total working days: ${totalWorkingDays}`);
    console.log(`Present days: ${presentDays.toFixed(2)}`);
    console.log(`Absent days: ${absentDays.toFixed(2)}`);
    console.log(`Paid leave days: ${paidLeaveDays.toFixed(2)}`);
    console.log(`Unpaid leave days: ${unpaidLeaveDays.toFixed(2)}`);
    console.log(`Weekends: ${countWeekends}`);
    console.log(`Holidays: ${countHolidays}`);
    console.log(`\n VALIDATION: Total accounted = ${totalAccounted.toFixed(2)} / ${totalWorkingDays}`);
    
    if (totalAccounted > totalWorkingDays + 0.01) {
        console.warn(` WARNING: Total days (${totalAccounted.toFixed(2)}) exceeds working days (${totalWorkingDays})!`);
    }

    console.log("\n DEDUCTIONS:");
    console.log(`Early out time deduction: ${earlyOutTimeDeductionDays.toFixed(2)} days`);
    console.log(`Counter penalty deduction: ${penaltyDeductionDays.toFixed(2)} days`);
    console.log(`Missing clock out penalty: ${missingClockOutPenaltyAmount.toFixed(2)}`);
    console.log(`Instant late in penalty: ${instantLateInPenaltyAmount.toFixed(2)}`);
    console.log(`Instant early out penalty: ${instantEarlyOutPenaltyAmount.toFixed(2)}`);

    console.log("\n OVERTIME:");
    console.log(`Total overtime amount: â‚¹${totalOvertimeAmount.toFixed(2)}`);

    const payableDays = presentDays + paidLeaveDays
        + (paySchedule.payForWeekends ? countWeekends : 0)
        + (paySchedule.payForHolidays ? countHolidays : 0);

    const totalUnpaidDays = earlyOutTimeDeductionDays + penaltyDeductionDays;
    const totalAmountPenalties = missingClockOutPenaltyAmount + instantLateInPenaltyAmount + instantEarlyOutPenaltyAmount;
    const unpaidDeduction = (perDaySalary * totalUnpaidDays) + totalAmountPenalties;

    const grossEarnings = (perDaySalary * payableDays) + totalOvertimeAmount - unpaidDeduction;

    console.log("\n SALARY CALCULATION:");
    console.log(`Per day salary: ${perDaySalary.toFixed(2)}`);
    console.log(`Payable days: ${payableDays.toFixed(2)}`);
    console.log(`Unpaid days: ${totalUnpaidDays.toFixed(2)}`);
    console.log(`Amount penalties: ${totalAmountPenalties.toFixed(2)}`);
    console.log(`Unpaid deduction: ${unpaidDeduction.toFixed(2)}`);
    console.log(`Gross earnings: ${grossEarnings.toFixed(2)}`);

    return {
        totalWorkingDays,
        countWeekends,
        countHolidays,
        presentDays: Number(presentDays.toFixed(2)),
        absentDays: Number(absentDays.toFixed(2)),
        paidLeaveDays: Number(paidLeaveDays.toFixed(2)),
        unpaidLeaveDays: Number(unpaidLeaveDays.toFixed(2)),

        earlyOutTimeDeductionDays: Number(earlyOutTimeDeductionDays.toFixed(2)),

        totalLateCount,
        totalEarlyOutCount,
        totalMissingClockOutCount,

        penaltyDeductionDays: Number(penaltyDeductionDays.toFixed(2)),
        missingClockOutPenaltyAmount: Number(missingClockOutPenaltyAmount.toFixed(2)),
        instantLateInPenaltyAmount: Number(instantLateInPenaltyAmount.toFixed(2)),
        instantEarlyOutPenaltyAmount: Number(instantEarlyOutPenaltyAmount.toFixed(2)),
        
        perDaySalary: Number(perDaySalary.toFixed(2)),
        payableDays: Number(payableDays.toFixed(2)),
        totalUnpaidDays: Number(totalUnpaidDays.toFixed(2)),
        totalAmountPenalties: Number(totalAmountPenalties.toFixed(2)),
        unpaidDeduction: Number(unpaidDeduction.toFixed(2)),

        totalOvertimeSeconds: otSecondsWorking + otSecondsWeekend + otSecondsHoliday,
        totalOvertimeAmount: Number(totalOvertimeAmount.toFixed(2)),
        grossEarnings: Number(grossEarnings.toFixed(2))
    };
};

export default SalaryCalculationfunction;