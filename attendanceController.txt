import User from "../models/auth.js";
import Shift from "../models/Shift.js";
import Attendance from "../models/Attendance.js";
import AttendanceLog from "../models/AttendanceLog.js";
import { getISTDate, getISTTime } from "../utils/time.js";
import jwt from "jsonwebtoken";
import dotenv from "dotenv";

dotenv.config();
const AttendanceController = async ({ type, data }, callback) => {
    try {
        const { token } = data;
        if (!token) return callback({ success: false, error: "Unauthorized: No token provided" });

        // Verify token
        const decoded = jwt.verify(token, process.env.JWT_SECRET_KEY);
        const user = await User.findById(decoded.id).populate("assignedShift");
        console.log(user)
        if (!user) return callback({ success: false, error: "User not found" });

        const date = getISTDate();
        const time = getISTTime();

        // ðŸ”‘ Common Attendance Fetch (sirf ek baar)
        let attendanceRecord = null;
        if (user.assignedShift) {
            attendanceRecord = await Attendance.findOne({
                userId: user._id,
                shiftId: user.assignedShift._id,
                date,
            });
        }
        console.log("attendance record", attendanceRecord)

        switch (type) {
            case "clockIn": {
                if (!user.assignedShift) {
                    return callback({ success: false, error: "No shift assigned to user" });
                }

                if (attendanceRecord) {
                    return callback({ success: false, error: "Already clocked in today" });
                }

                // Attendance create
                const attendance = await Attendance.create({
                    userId: user._id,
                    shiftId: user.assignedShift._id,
                    date,
                    clockIn: time,
                });

                const attendanceLog = await AttendanceLog.create({
                    attendanceId: attendance._id,
                    userId: user._id,
                    date,
                    type: 1,
                    clockIn: attendance.clockIn,
                });

                return callback({
                    success: true,
                    message: "Clock-in successful",
                    attendance,
                    attendanceLog,
                });
            }

            case "breakIn": {
                if (!attendanceRecord) {
                    return callback({ success: false, error: "Attendance not found for today" });
                }

                const { reason } = data;

                const breakLog = await AttendanceLog.create({
                    attendanceId: attendanceRecord._id,
                    userId: user._id,
                    date,
                    type: 2,
                    breakIn: time,
                    reason,
                });

                // Update last work log (type 1) clockOut
                const lastWorkLog = await AttendanceLog.findOne({
                    attendanceId: attendanceRecord._id,
                    userId: user._id,
                    type: 1,
                    clockOut: null,
                }).sort({ createdAt: -1 });

                if (lastWorkLog) {
                    lastWorkLog.clockOut = time;
                    await lastWorkLog.save();
                }

                return callback({
                    success: true,
                    message: "Break started",
                    breakLog,
                });
            }


            case "breakOut": {
                if (!attendanceRecord) {
                    return callback({ success: false, error: "Attendance not found for today" });
                }
                let totalBreakSecond;
                const lastWorkLog = await AttendanceLog.findOne({
                    attendanceId: attendanceRecord._id,
                    userId: user._id,
                    type: 2
                }).sort({ createdAt: -1 });

                if (lastWorkLog) {
                    lastWorkLog.breakOut = time;
                    totalBreakSecond = lastWorkLog.breakOut - lastWorkLog.breakIn;
                    console.log(totalBreakSecond);
                    lastWorkLog.breakDuration = totalBreakSecond;
                    await lastWorkLog.save();
                }

                const breakOutLog = await AttendanceLog.create({
                    attendanceId: attendanceRecord._id,
                    userId: user._id,
                    date,
                    type: 1,
                    clockIn: time,
                })

                if (!attendanceRecord.totalBreakSeconds) {
                    attendanceRecord.totalBreakSeconds = totalBreakSecond;
                    await attendanceRecord.save();
                    
                }



                return callback({
                    success: true,
                    message: "Break end",
                    breakOutLog,
                    attendanceRecord
                });



            }

            default:
                return callback({ success: false, error: "Invalid type" });
        }
    } catch (err) {
        console.error("AttendanceController Error:", err);
        return callback({ success: false, error: "Internal server error" });
    }
};


export default AttendanceController;
















      // case "clockIn": {

      //   // prevent double clock in
      //   const activeWorkLog = await AttendanceLog.findOne({
      //     userId: user._id,
      //     type: ENUMS.LOG_TYPE.WORK,
      //     outTime: null,
      //   });
      //   if (activeWorkLog) return callback({ success: false, error: "Already clocked in" });

      //   const holiday = await Holiday.findOne({
      //     startDate: { $lte: attendanceDate },
      //     endDate: { $gte: attendanceDate }
      //   });
      //   const isHoliday = holiday && (holiday.assignUsers.length === 0 || holiday.assignUsers.some(uId => uId.equals(user._id)));
      //   console.log("holiday details", holiday);
      //   if (holiday) {
      //     let attendance;
      //     // Check if global holiday or assigned to user
      //     if (holiday.assignUsers.length === 0 || holiday.assignUsers.some(uId => uId.equals(user._id))) {
      //       if (user.assignedOvertimePolicy) {
      //         const otpolicy = await OvertimePolicy.findById(user.assignedOvertimePolicy);
      //         console.log(otpolicy);

      //         // Holiday attendance entry
      //         attendance = await Attendance.create({
      //           userId: user._id,
      //           shiftId: user.assignedShift._id,
      //           date: attendanceDate,
      //           clockIn: currentTimeUTC,
      //           totalWorkSeconds: 0,
      //           totalBreakSeconds: 0,
      //           dayStatus: ENUMS.DAY_STATUS.HOLIDAY
      //         });


      //         await AttendanceLog.create({
      //           attendanceId: attendance._id,
      //           userId: user._id,
      //           type: ENUMS.LOG_TYPE.WORK,
      //           inTime: currentTimeUTC,
      //           outTime: null,
      //         });
      //         return callback({ success: true, message: "Holiday attendance (Overtime) recorded", attendance });
      //       } else {
      //         attendance = await Attendance.create({
      //           userId: user._id,
      //           shiftId: user.assignedShift._id,
      //           date: attendanceDate,
      //           clockIn: null,
      //           totalWorkSeconds: 0,
      //           totalBreakSeconds: 0,
      //           dayStatus: ENUMS.DAY_STATUS.HOLIDAY
      //         });
      //         return callback({
      //           success: true,
      //           message: "Today is a holiday. Attendance recorded as holiday.",
      //           attendance,
      //           holiday: { name: holiday.name, description: holiday.description }
      //         });
      //       }

      //     }
      //   }

      //   if (!user.assignedShift) return callback({ success: false, error: "No shift assigned" });

      //   // day of week based on IST
      //   const istForDay = new Date(attendanceDate.getTime() + IST_OFFSET_MIN * 60 * 1000);
      //   const dayOfWeek = istForDay.getUTCDay();

      //   const shiftDay = user.assignedShift.days.get(String(dayOfWeek));
      //   console.log(shiftDay);
      //   if (!shiftDay) return callback({ success: false, error: "Shift not defined for today" });

      //   // WEEKEND check
      //   if (shiftDay?.dayStatus === ENUMS.DAY_STATUS.WEEKEND) {
      //     if (!user.assignedOvertimePolicy) {
      //       return callback({ success: false, error: "Weekend day. No OT policy assigned, cannot clock in." });
      //     }

      //     const attendance = await Attendance.create({
      //       userId: user._id,
      //       shiftId: user.assignedShift?._id,
      //       date: attendanceDate,
      //       clockIn: currentTimeUTC,
      //       totalWorkSeconds: 0,
      //       totalBreakSeconds: 0,
      //       dayStatus: ENUMS.DAY_STATUS.WEEKEND,
      //       isOverTime: false,
      //     });

      //     await AttendanceLog.create({
      //       attendanceId: attendance._id,
      //       userId: user._id,
      //       type: ENUMS.LOG_TYPE.WORK,
      //       inTime: currentTimeUTC,
      //       outTime: null,
      //     });

      //     return callback({ success: true, message: "Weekend Clock-in recorded", todayAttendance: attendance });
      //   }

      //   // shift start utc
      //   const shiftStartUTC = getShiftStartUTC(shiftDay.start, attendanceDate);

      //   // grace 15 minutes
      //   const { lateIn, lateInDuration } = calculateLateIn(shiftStartUTC, currentTimeUTC, 15);
      //   console.log(lateIn, lateInDuration);



      //   // create attendance if not exists
      //   if (!todayAttendance) {
      //     todayAttendance = await Attendance.create({
      //       userId: user._id,
      //       shiftId: user.assignedShift._id,
      //       date: attendanceDate,
      //       clockIn: currentTimeUTC,
      //       islateIn: lateIn,
      //       lateInDuration,
      //       totalWorkSeconds: 0,
      //       totalBreakSeconds: 0,
      //       dayStatus: shiftDay.dayStatus || ENUMS.DAY_STATUS.WORKING

      //     });
      //   } else {
      //     todayAttendance.isEarlyOut = false;
      //     todayAttendance.EarlyOutDuration = 0;
      //     await todayAttendance.save();
      //   }

      //   const workLog = await AttendanceLog.create({
      //     attendanceId: todayAttendance._id,
      //     userId: user._id,
      //     date: attendanceDate,
      //     type: ENUMS.LOG_TYPE.WORK,
      //     inTime: currentTimeUTC,
      //   });

      //   return callback({ success: true, message: "Clock-in successful", todayAttendance, workLog });
      // }

      case "breakIn": {
        if (!todayAttendance) return callback({ success: false, error: "Attendance not found" });

        const activeWorkLog = await AttendanceLog.findOne({
          attendanceId: todayAttendance._id,
          userId: user._id,
          type: ENUMS.LOG_TYPE.WORK,
          outTime: null,
        });
        if (!activeWorkLog) return callback({ success: false, error: "No active work session to start break" });

        activeWorkLog.outTime = currentTimeUTC;
        activeWorkLog.workDuration = durationInSeconds(activeWorkLog.inTime, activeWorkLog.outTime);
        await activeWorkLog.save();

        todayAttendance.totalWorkSeconds = (todayAttendance.totalWorkSeconds || 0) + activeWorkLog.workDuration;
        await todayAttendance.save();

        const breakLog = await AttendanceLog.create({
          attendanceId: todayAttendance._id,
          userId: user._id,
          date: attendanceDate,
          type: ENUMS.LOG_TYPE.BREAK,
          inTime: currentTimeUTC,
          reason,
        });

        return callback({ success: true, message: "Break started", todayAttendance, breakLog });
      }

      case "breakOut": {
        if (!todayAttendance) return callback({ success: false, error: "Attendance not found" });

        const activeBreakLog = await AttendanceLog.findOne({
          attendanceId: todayAttendance._id,
          userId: user._id,
          type: ENUMS.LOG_TYPE.BREAK,
          outTime: null,
        });
        if (!activeBreakLog) return callback({ success: false, error: "No active break to end" });

        activeBreakLog.outTime = currentTimeUTC;
        activeBreakLog.breakDuration = durationInSeconds(activeBreakLog.inTime, activeBreakLog.outTime);
        await activeBreakLog.save();

        todayAttendance.totalBreakSeconds = (todayAttendance.totalBreakSeconds || 0) + activeBreakLog.breakDuration;
        await todayAttendance.save();

        // resume work
        const workLog = await AttendanceLog.create({
          attendanceId: todayAttendance._id,
          userId: user._id,
          date: attendanceDate,
          type: ENUMS.LOG_TYPE.WORK,
          inTime: currentTimeUTC,
        });

        return callback({ success: true, message: "Break ended, work resumed", todayAttendance, workLog });
      }

      case "clockOut": {
        if (!todayAttendance) return callback({ success: false, error: "Attendance not found" });
        // -- Validation 
        const activeBreakLog = await AttendanceLog.findOne({
          attendanceId: todayAttendance._id,
          userId: user._id,
          type: ENUMS.LOG_TYPE.BREAK,
          outTime: null,
        });
        if (activeBreakLog) return callback({ success: false, error: "You are in break" });

        const activeWorkLog = await AttendanceLog.findOne({
          attendanceId: todayAttendance._id,
          userId: user._id,
          type: ENUMS.LOG_TYPE.WORK,
          outTime: null,
        });
        if (!activeWorkLog) return callback({ success: false, error: "No active work session to clock out" });

        activeWorkLog.outTime = currentTimeUTC;
        activeWorkLog.workDuration = durationInSeconds(activeWorkLog.inTime, activeWorkLog.outTime);
        await activeWorkLog.save();

        todayAttendance.totalWorkSeconds =
          (todayAttendance.totalWorkSeconds || 0) + activeWorkLog.workDuration;
        // (todayAttendance.totalWorkSeconds || 0) + (activeWorkLog.workDuration * 120); for testing
        todayAttendance.clockOut = currentTimeUTC;

        if (user.assignedShift) {
          const istForDay = new Date(attendanceDate.getTime() + IST_OFFSET_MIN * 60 * 1000);
          const dayOfWeek = istForDay.getUTCDay();
          const shiftDay = user.assignedShift.days.get(String(dayOfWeek));
          console.log(shiftDay);

          if (shiftDay) {
            const shiftEndUTC = getShiftEndUTC(shiftDay.end, attendanceDate);
            const { earlyOut, earlyOutDuration } = checkEarlyOut(currentTimeUTC, shiftEndUTC, 10); // 10 min grace
            todayAttendance.isEarlyOut = earlyOut;
            todayAttendance.EarlyOutDuration = earlyOutDuration;

          }

          if (user.assignedOvertimePolicy) {
            const otpolicy = await OvertimePolicy.findById(user.assignedOvertimePolicy);
            console.log(otpolicy);

            console.log("total ", todayAttendance.totalWorkSeconds);
            console.log("shift ", user.assignedShift.fullDayHrs * 3600)

            if (todayAttendance.totalWorkSeconds > (user.assignedShift.fullDayHrs * 3600)) {
              const extratime = todayAttendance.totalWorkSeconds - (user.assignedShift.fullDayHrs * 3600);
              // console.log("bahar", extratime);
              todayAttendance.isOverTime = true;
              todayAttendance.ExtraTime = extratime;
            }

            if (shiftDay?.dayStatus === (ENUMS.DAY_STATUS.FIRSTHALF || ENUMS.DAY_STATUS.SECONDHALF)) {

              if (todayAttendance.totalWorkSeconds > (user.assignedShift.fullDayHrs * 3600)) {
                const extratime = todayAttendance.totalWorkSeconds - (user.assignedShift.fullDayHrs * 3600);
                console.log("bahar", extratime);
                todayAttendance.isOverTime = true;
                todayAttendance.ExtraTime = extratime;
              }

            }

          }

        }

        await todayAttendance.save();

        return callback({ success: true, message: "Clock-out successful", todayAttendance });
      }

      default:
        return callback({ success: false, error: "Invalid type" });
    }
  } catch (err) {
    console.error("AttendanceController Error:", err);
    return callback({ success: false, error: "Internal server error" });
  }
};

export default AttendanceController;





if (user.assignedOvertimePolicy) {
  const otPolicy = await OvertimePolicy.findById(user.assignedOvertimePolicy);

  let overtimePay = 0;
  if (otPolicy.payFactorType === "MULTIPLIER") {
      const multiplier = todayAttendance.dayStatus === ENUMS.DAY_STATUS.HOLIDAY 
                          ? otPolicy.holidayMultiplier 
                          : (todayAttendance.dayStatus === ENUMS.DAY_STATUS.WEEKEND 
                             ? otPolicy.weekendMultiplier 
                             : otPolicy.workingMultiplier);
      overtimePay = (todayAttendance.ExtraTime / 3600) * user.hourlyRate * multiplier;
  } else if (otPolicy.payFactorType === "FIXED_PER_HOUR") {
      overtimePay = (todayAttendance.ExtraTime / 3600) * otPolicy.payPerHour;
  } else if (otPolicy.payFactorType === "FIXED_TOTAL") {
      overtimePay = otPolicy.fixedTotal;
  }

  todayAttendance.overtimePay = overtimePay;
}






//right code

      // case "clockIn": {

      //   // prevent double clock in
      //   const activeWorkLog = await AttendanceLog.findOne({
      //     userId: user._id,
      //     type: ENUMS.LOG_TYPE.WORK,
      //     outTime: null,
      //   });
      //   if (activeWorkLog) return callback({ success: false, error: "Already clocked in" });

      //   const holiday = await Holiday.findOne({
      //     startDate: { $lte: attendanceDate },
      //     endDate: { $gte: attendanceDate }
      //   });
      //   const isHoliday = holiday && (holiday.assignUsers.length === 0 || holiday.assignUsers.some(uId => uId.equals(user._id)));
      //   console.log("holiday details", holiday);
      //   if (holiday) {
      //     let attendance;
      //     // Check if global holiday or assigned to user
      //     if (holiday.assignUsers.length === 0 || holiday.assignUsers.some(uId => uId.equals(user._id))) {
      //       if (user.assignedOvertimePolicy) {
      //         const otpolicy = await OvertimePolicy.findById(user.assignedOvertimePolicy);
      //         console.log(otpolicy);

      //         // Holiday attendance entry
      //         attendance = await Attendance.create({
      //           userId: user._id,
      //           shiftId: user.assignedShift._id,
      //           date: attendanceDate,
      //           clockIn: currentTimeUTC,
      //           totalWorkSeconds: 0,
      //           totalBreakSeconds: 0,
      //           dayStatus: ENUMS.DAY_STATUS.HOLIDAY
      //         });


      //         await AttendanceLog.create({
      //           attendanceId: attendance._id,
      //           userId: user._id,
      //           type: ENUMS.LOG_TYPE.WORK,
      //           inTime: currentTimeUTC,
      //           outTime: null,
      //         });
      //         return callback({ success: true, message: "Holiday attendance (Overtime) recorded", attendance });
      //       } else {
      //         attendance = await Attendance.create({
      //           userId: user._id,
      //           shiftId: user.assignedShift._id,
      //           date: attendanceDate,
      //           clockIn: null,
      //           totalWorkSeconds: 0,
      //           totalBreakSeconds: 0,
      //           dayStatus: ENUMS.DAY_STATUS.HOLIDAY
      //         });
      //         return callback({
      //           success: true,
      //           message: "Today is a holiday. Attendance recorded as holiday.",
      //           attendance,
      //           holiday: { name: holiday.name, description: holiday.description }
      //         });
      //       }

      //     }
      //   }

      //   if (!user.assignedShift) return callback({ success: false, error: "No shift assigned" });

      //   // day of week based on IST
      //   const istForDay = new Date(attendanceDate.getTime() + IST_OFFSET_MIN * 60 * 1000);
      //   const dayOfWeek = istForDay.getUTCDay();

      //   const shiftDay = user.assignedShift.days.get(String(dayOfWeek));
      //   console.log(shiftDay);
      //   if (!shiftDay) return callback({ success: false, error: "Shift not defined for today" });

      //   // WEEKEND check
      //   if (shiftDay?.dayStatus === ENUMS.DAY_STATUS.WEEKEND) {
      //     if (!user.assignedOvertimePolicy) {
      //       return callback({ success: false, error: "Weekend day. No OT policy assigned, cannot clock in." });
      //     }

      //     const attendance = await Attendance.create({
      //       userId: user._id,
      //       shiftId: user.assignedShift?._id,
      //       date: attendanceDate,
      //       clockIn: currentTimeUTC,
      //       totalWorkSeconds: 0,
      //       totalBreakSeconds: 0,
      //       dayStatus: ENUMS.DAY_STATUS.WEEKEND,
      //       isOverTime: false,
      //     });

      //     await AttendanceLog.create({
      //       attendanceId: attendance._id,
      //       userId: user._id,
      //       type: ENUMS.LOG_TYPE.WORK,
      //       inTime: currentTimeUTC,
      //       outTime: null,
      //     });

      //     return callback({ success: true, message: "Weekend Clock-in recorded", todayAttendance: attendance });
      //   }

      //   // shift start utc
      //   const shiftStartUTC = getShiftStartUTC(shiftDay.start, attendanceDate);

      //   // grace 15 minutes
      //   const { lateIn, lateInDuration } = calculateLateIn(shiftStartUTC, currentTimeUTC, 15);
      //   console.log(lateIn, lateInDuration);



      //   // create attendance if not exists
      //   if (!todayAttendance) {
      //     todayAttendance = await Attendance.create({
      //       userId: user._id,
      //       shiftId: user.assignedShift._id,
      //       date: attendanceDate,
      //       clockIn: currentTimeUTC,
      //       islateIn: lateIn,
      //       lateInDuration,
      //       totalWorkSeconds: 0,
      //       totalBreakSeconds: 0,
      //       dayStatus: shiftDay.dayStatus || ENUMS.DAY_STATUS.WORKING

      //     });
      //   } else {
      //     todayAttendance.isEarlyOut = false;
      //     todayAttendance.EarlyOutDuration = 0;
      //     await todayAttendance.save();
      //   }

      //   const workLog = await AttendanceLog.create({
      //     attendanceId: todayAttendance._id,
      //     userId: user._id,
      //     date: attendanceDate,
      //     type: ENUMS.LOG_TYPE.WORK,
      //     inTime: currentTimeUTC,
      //   });

      //   return callback({ success: true, message: "Clock-in successful", todayAttendance, workLog });
      // }





      // Early-in detection (arrived more than EARLYIN_THRESHOLD_MIN before shift start)
        // let earlyIn = false;
        // const earlyThresholdMillis = EARLYIN_THRESHOLD_MIN * 60 * 1000;
        // if (currentTimeUTC.getTime() < (shiftStartUTC.getTime() - earlyThresholdMillis)) {
        //   earlyIn = true;
        // }








      case "clockOut": {
         if (!todayAttendance) return callback({ success: false, error: "Attendance not found" });
          const activeBreakLog = await AttendanceLog.findOne({
            attendanceId: todayAttendance._id,
            userId: user._id,
            type: ENUMS.LOG_TYPE.BREAK,
            outTime: null,
          });
          if (activeBreakLog) return callback({ success: false, error: "You are in break" });

          const activeWorkLog = await AttendanceLog.findOne({
            attendanceId: todayAttendance._id,
            userId: user._id,
            type: ENUMS.LOG_TYPE.WORK,
            outTime: null,
          });
          if (!activeWorkLog) return callback({ success: false, error: "No active work session to clock out" });

          activeWorkLog.outTime = currentTimeUTC;
          activeWorkLog.workDuration = durationInSeconds(activeWorkLog.inTime, activeWorkLog.outTime);
          await activeWorkLog.save();

          todayAttendance.totalWorkSeconds =
            (todayAttendance.totalWorkSeconds || 0) + activeWorkLog.workDuration;
        (todayAttendance.totalWorkSeconds || 0) + (activeWorkLog.workDuration * 120);
        todayAttendance.clockOut = currentTimeUTC;

        const istForDay = new Date(attendanceDate.getTime() + IST_OFFSET_MIN * 60 * 1000);
        const dayOfWeek = istForDay.getUTCDay();
        const shiftDay = user.assignedShift?.days?.get(String(dayOfWeek));
        console.log(shiftDay);


        if (todayAttendance.dayStatus === ENUMS.DAY_STATUS.HOLIDAY || todayAttendance.dayStatus === ENUMS.DAY_STATUS.WEEKEND) {
          if ((todayAttendance.totalWorkSeconds || 0) > 0) {
            todayAttendance.isOverTime = true;
            todayAttendance.ExtraTime = todayAttendance.totalWorkSeconds;

          }
        if (ot && todayAttendance.ExtraTime > (60 * 60 * 1000)) { // 60s*1000ms = 1min

          if (ot.payFactorType === ENUMS.payFactorType.MULTIPLIER && todayAttendance.dayStatus === ENUMS.DAY_STATUS.HOLIDAY) {
               if(userSalary.frequencyType === ENUMS.salaryFrequency.MONTHLY){
                 const currentsalary = userSalary.salary
               }
          }
        }
          await todayAttendance.save();
          return callback({ success: true, message: `${todayAttendance.dayStatus} clock-out (OT calculated)`, todayAttendance });
        }

        const shiftEndUTC = getShiftEndUTC(shiftDay.end, attendanceDate);
        const { earlyOut, earlyOutDuration } = checkEarlyOut(currentTimeUTC, shiftEndUTC, GRACE_EARLYOUT_MIN); // 10 min grace
        todayAttendance.isEarlyOut = earlyOut;
        todayAttendance.EarlyOutDuration = earlyOutDuration;
        const otpolicy = await OvertimePolicy.findById(user.assignedOvertimePolicy);
        console.log(otpolicy);
          let shiftSeconds = 0;
          if (
            shiftDay?.dayStatus === ENUMS.DAY_STATUS.FIRSTHALF ||
            shiftDay?.dayStatus === ENUMS.DAY_STATUS.SECONDHALF
          ) {
            shiftSeconds = (user.assignedShift?.halfDayHrs || 0) * 3600;
          } else {
            shiftSeconds = (user.assignedShift?.fullDayHrs || 0) * 3600;
          }
          console.log(shiftSeconds);

          if (todayAttendance.totalWorkSeconds > shiftSeconds) {
            const extratime = Math.max(0, todayAttendance.totalWorkSeconds - shiftSeconds);
            todayAttendance.isOverTime = true;
            todayAttendance.ExtraTime = extratime;
          }
        await todayAttendance.save();
        return callback({ success: true, message: "Clock-out successful", todayAttendance });
      }